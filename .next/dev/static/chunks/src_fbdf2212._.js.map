{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 4, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/services/api.ts"],"sourcesContent":["import { Message } from \"../types\";\r\n\r\nconst COMMUNICATION_HUB_URL = \"http://127.0.0.1:3005\";\r\n\r\nexport const fetchMessages = async (sinceTimestamp: number = 0): Promise<Message[]> => {\r\n    try {\r\n        const res = await fetch(`${COMMUNICATION_HUB_URL}/getMessages?lastTimestamp=${sinceTimestamp}`);\r\n        if (!res.ok) {\r\n            throw new Error(`Server error: ${res.status}`);\r\n        }\r\n        const data = await res.json();\r\n        if (data.success && Array.isArray(data.messages)) {\r\n            return data.messages;\r\n        }\r\n        return [];\r\n    } catch (error) {\r\n        console.error(\"Failed to fetch messages:\", error);\r\n        return [];\r\n    }\r\n};\r\n\r\nexport const fetchBotHistory = async (botId: string, limit: number = 100): Promise<Message[]> => {\r\n    // For now, we reuse getMessages but in real implementation efficient history fetch might happen \r\n    // via a dedicated endpoint if DB grows large.\r\n    return fetchMessages(0);\r\n}\r\n\r\nexport const sendCommand = async (command: any): Promise<boolean> => {\r\n    try {\r\n        const res = await fetch(`${COMMUNICATION_HUB_URL}/sendCommand`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify(command)\r\n        });\r\n        const data = await res.json();\r\n        return data.success;\r\n    } catch (error) {\r\n        console.error(\"Failed to send command:\", error);\r\n        return false;\r\n    }\r\n};\r\n\r\n// --- LIVE CHART API ---\r\n\r\nexport const fetchSymbols = async (botId?: string): Promise<string[]> => {\r\n    try {\r\n        const url = botId ? `${COMMUNICATION_HUB_URL}/symbols?botId=${botId}` : `${COMMUNICATION_HUB_URL}/symbols`;\r\n        const res = await fetch(url);\r\n        if (res.status === 503) {\r\n            throw new Error(\"No Master Account Configured\");\r\n        }\r\n        const data = await res.json();\r\n\r\n        // Fallback: If configured list is empty, try getting ALL available symbols?\r\n        // This helps if the User hasn't configured anything yet.\r\n        if (!data.symbols || data.symbols.length === 0) {\r\n            try {\r\n                // Try alternate endpoint if it exists\r\n                const res2 = await fetch(`${COMMUNICATION_HUB_URL}/available-symbols`);\r\n                const data2 = await res2.json();\r\n                if (data2.symbols && data2.symbols.length > 0) return data2.symbols;\r\n            } catch (e2) { }\r\n        }\r\n\r\n        return data.symbols || [];\r\n    } catch (error) {\r\n        console.error(\"Failed to fetch symbols:\", error);\r\n        throw error; // Re-throw to let UI handle it\r\n    }\r\n};\r\n\r\nexport const startStream = async (clientId: string, symbol: string): Promise<boolean> => {\r\n    try {\r\n        await fetch(`${COMMUNICATION_HUB_URL}/stream/start`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ clientId, symbol })\r\n        });\r\n        return true;\r\n    } catch (error) {\r\n        console.error(\"Failed to start stream:\", error);\r\n        return false;\r\n    }\r\n};\r\n\r\nexport const sendKeepAlive = async (clientId: string): Promise<boolean> => {\r\n    try {\r\n        await fetch(`${COMMUNICATION_HUB_URL}/stream/keepalive`, {\r\n            method: \"POST\",\r\n            headers: { \"Content-Type\": \"application/json\" },\r\n            body: JSON.stringify({ clientId })\r\n        });\r\n        return true;\r\n    } catch (error) {\r\n        return false; // Silent fail\r\n    }\r\n};\r\n\r\nexport const fetchTicks = async (clientId: string): Promise<any[]> => {\r\n    try {\r\n        const res = await fetch(`${COMMUNICATION_HUB_URL}/stream/ticks?clientId=${clientId}`);\r\n        const data = await res.json();\r\n        return data.ticks || [];\r\n    } catch (error) {\r\n        return [];\r\n    }\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 132, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/services/TradeLogService.ts"],"sourcesContent":["export interface TradeLogEntry {\r\n    id: string;\r\n    timestamp: number;\r\n    symbol: string;\r\n    direction: 'LONG' | 'SHORT';\r\n    entryPrice: number;\r\n    stopLoss: number;\r\n    takeProfit: number;\r\n    riskReward: number;\r\n    orderType: string;\r\n    // Concrete Initial Levels for Visualization\r\n    initialEntry?: number;\r\n    initialSL?: number;\r\n    initialTP?: number;\r\n    rawTrade: any;\r\n}\r\n\r\nconst STORAGE_KEY_COUNTER = 'trade_counter_seq';\r\nconst STORAGE_KEY_LOG = 'trade_log_db';\r\n\r\nexport class TradeLogService {\r\n\r\n    /**\r\n     * generating a sequential ID (e.g. \"1005\")\r\n     */\r\n    static getNextId(): string {\r\n        try {\r\n            const current = localStorage.getItem(STORAGE_KEY_COUNTER);\r\n            let next = current ? parseInt(current, 10) + 1 : 1000; // Start at 1000 if empty\r\n            if (isNaN(next)) next = 1000;\r\n\r\n            localStorage.setItem(STORAGE_KEY_COUNTER, next.toString());\r\n            return next.toString();\r\n        } catch (e) {\r\n            console.error(\"TradeLogService: Failed to access localStorage\", e);\r\n            return \"ERR-\" + Date.now();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Log the trade to persistent storage\r\n     */\r\n    static logTrade(trade: any): void {\r\n        try {\r\n            const entry: TradeLogEntry = {\r\n                id: trade.id || 'UNKNOWN',\r\n                timestamp: Date.now(),\r\n                symbol: trade.symbol,\r\n                direction: trade.direction,\r\n                entryPrice: trade.entry?.price || 0,\r\n                stopLoss: trade.sl?.price || 0,\r\n                takeProfit: trade.tp?.price || 0,\r\n                riskReward: trade.riskReward?.value || 0,\r\n                orderType: trade.orderType,\r\n                // Capture Concrete Initial Levels\r\n                initialEntry: trade.meta?.initialEntry || trade.entry?.price || 0,\r\n                initialSL: trade.meta?.initialSL || trade.sl?.price || 0,\r\n                initialTP: trade.meta?.initialTP || trade.tp?.price || 0,\r\n                rawTrade: trade\r\n            };\r\n\r\n            const existingLogsJson = localStorage.getItem(STORAGE_KEY_LOG);\r\n            const logs: TradeLogEntry[] = existingLogsJson ? JSON.parse(existingLogsJson) : [];\r\n\r\n            // Prepend new trade\r\n            logs.unshift(entry);\r\n\r\n            // Limit log size (optional, e.g. 500)\r\n            if (logs.length > 500) logs.pop();\r\n\r\n            localStorage.setItem(STORAGE_KEY_LOG, JSON.stringify(logs));\r\n            console.log(\"[TradeLogService] Logged Trade:\", entry);\r\n\r\n        } catch (e) {\r\n            console.error(\"TradeLogService: Failed to log trade\", e);\r\n        }\r\n    }\r\n\r\n    static getLogs(): TradeLogEntry[] {\r\n        try {\r\n            const existingLogsJson = localStorage.getItem(STORAGE_KEY_LOG);\r\n            return existingLogsJson ? JSON.parse(existingLogsJson) : [];\r\n        } catch (e) {\r\n            return [];\r\n        }\r\n    }\r\n}\r\n"],"names":[],"mappings":";;;;AAiBA,MAAM,sBAAsB;AAC5B,MAAM,kBAAkB;AAEjB,MAAM;IAET;;KAEC,GACD,OAAO,YAAoB;QACvB,IAAI;YACA,MAAM,UAAU,aAAa,OAAO,CAAC;YACrC,IAAI,OAAO,UAAU,SAAS,SAAS,MAAM,IAAI,MAAM,yBAAyB;YAChF,IAAI,MAAM,OAAO,OAAO;YAExB,aAAa,OAAO,CAAC,qBAAqB,KAAK,QAAQ;YACvD,OAAO,KAAK,QAAQ;QACxB,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,kDAAkD;YAChE,OAAO,SAAS,KAAK,GAAG;QAC5B;IACJ;IAEA;;KAEC,GACD,OAAO,SAAS,KAAU,EAAQ;QAC9B,IAAI;YACA,MAAM,QAAuB;gBACzB,IAAI,MAAM,EAAE,IAAI;gBAChB,WAAW,KAAK,GAAG;gBACnB,QAAQ,MAAM,MAAM;gBACpB,WAAW,MAAM,SAAS;gBAC1B,YAAY,MAAM,KAAK,EAAE,SAAS;gBAClC,UAAU,MAAM,EAAE,EAAE,SAAS;gBAC7B,YAAY,MAAM,EAAE,EAAE,SAAS;gBAC/B,YAAY,MAAM,UAAU,EAAE,SAAS;gBACvC,WAAW,MAAM,SAAS;gBAC1B,kCAAkC;gBAClC,cAAc,MAAM,IAAI,EAAE,gBAAgB,MAAM,KAAK,EAAE,SAAS;gBAChE,WAAW,MAAM,IAAI,EAAE,aAAa,MAAM,EAAE,EAAE,SAAS;gBACvD,WAAW,MAAM,IAAI,EAAE,aAAa,MAAM,EAAE,EAAE,SAAS;gBACvD,UAAU;YACd;YAEA,MAAM,mBAAmB,aAAa,OAAO,CAAC;YAC9C,MAAM,OAAwB,mBAAmB,KAAK,KAAK,CAAC,oBAAoB,EAAE;YAElF,oBAAoB;YACpB,KAAK,OAAO,CAAC;YAEb,sCAAsC;YACtC,IAAI,KAAK,MAAM,GAAG,KAAK,KAAK,GAAG;YAE/B,aAAa,OAAO,CAAC,iBAAiB,KAAK,SAAS,CAAC;YACrD,QAAQ,GAAG,CAAC,mCAAmC;QAEnD,EAAE,OAAO,GAAG;YACR,QAAQ,KAAK,CAAC,wCAAwC;QAC1D;IACJ;IAEA,OAAO,UAA2B;QAC9B,IAAI;YACA,MAAM,mBAAmB,aAAa,OAAO,CAAC;YAC9C,OAAO,mBAAmB,KAAK,KAAK,CAAC,oBAAoB,EAAE;QAC/D,EAAE,OAAO,GAAG;YACR,OAAO,EAAE;QACb;IACJ;AACJ"}},
    {"offset": {"line": 201, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/services/socket.ts"],"sourcesContent":["\r\nimport { io, Socket } from 'socket.io-client';\r\n\r\nconst URL = 'http://127.0.0.1:3005';\r\n\r\nclass SocketService {\r\n    public socket: Socket;\r\n\r\n    constructor() {\r\n        this.socket = io(URL, {\r\n            autoConnect: true,\r\n            reconnection: true,\r\n            transports: ['websocket'], // FORCE Websocket to avoid 400 Bad Request Polling\r\n            withCredentials: true,\r\n        });\r\n\r\n        this.socket.on('connect', () => {\r\n            console.log('[Socket] Connected to market-data-core');\r\n        });\r\n\r\n        this.socket.on('disconnect', () => {\r\n            console.log('[Socket] Disconnected');\r\n        });\r\n    }\r\n\r\n    getSocket() {\r\n        return this.socket;\r\n    }\r\n}\r\n\r\n// Export singleton\r\nexport const socketService = new SocketService();\r\n"],"names":[],"mappings":";;;;AACA;;AAEA,MAAM,MAAM;AAEZ,MAAM;IACK,OAAe;IAEtB,aAAc;QACV,IAAI,CAAC,MAAM,GAAG,IAAA,wLAAE,EAAC,KAAK;YAClB,aAAa;YACb,cAAc;YACd,YAAY;gBAAC;aAAY;YACzB,iBAAiB;QACrB;QAEA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,WAAW;YACtB,QAAQ,GAAG,CAAC;QAChB;QAEA,IAAI,CAAC,MAAM,CAAC,EAAE,CAAC,cAAc;YACzB,QAAQ,GAAG,CAAC;QAChB;IACJ;IAEA,YAAY;QACR,OAAO,IAAI,CAAC,MAAM;IACtB;AACJ;AAGO,MAAM,gBAAgB,IAAI"}},
    {"offset": {"line": 238, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/services/CommunicationHub.ts"],"sourcesContent":["import { Socket } from \"socket.io-client\";\r\nimport { socketService } from \"./socket\";\r\n\r\nconst HUB_URL = \"http://127.0.0.1:3005\";\r\n\r\nclass CommunicationHub {\r\n    private socket: Socket;\r\n    private static instance: CommunicationHub;\r\n    private subscribers: Set<string> = new Set();\r\n    private reconnectTimer: NodeJS.Timeout | null = null;\r\n\r\n    private constructor() {\r\n        // Use the shared socket instance\r\n        this.socket = socketService.getSocket();\r\n        this.setupListeners();\r\n    }\r\n\r\n    public static getInstance(): CommunicationHub {\r\n        if (!CommunicationHub.instance) {\r\n            CommunicationHub.instance = new CommunicationHub();\r\n        }\r\n        return CommunicationHub.instance;\r\n    }\r\n\r\n    // Initialize listeners on the shared socket\r\n    private setupListeners() {\r\n        console.log(\"[CommunicationHub] Hooking into Shared Socket...\");\r\n\r\n        if (this.socket.connected) {\r\n            this.onConnect();\r\n        }\r\n\r\n        this.socket.on(\"connect\", () => this.onConnect());\r\n\r\n        this.socket.on(\"disconnect\", (reason) => {\r\n            console.warn(\"[CommunicationHub] Disconnected:\", reason);\r\n        });\r\n\r\n        this.socket.on(\"connect_error\", (err) => {\r\n            console.error(\"[CommunicationHub] Connection Error:\", err.message);\r\n        });\r\n    }\r\n\r\n    private onConnect() {\r\n        console.log(\"[CommunicationHub] Connected via Shared Socket:\", this.socket.id);\r\n        // Re-subscribe to all active symbols\r\n        this.subscribers.forEach(key => {\r\n            const parts = key.split('|');\r\n            const symbol = parts[0];\r\n            const tf = parts.length > 1 ? parts[1] : \"M1\";\r\n            this.socket.emit(\"subscribe\", symbol, tf);\r\n        });\r\n    }\r\n\r\n    // Deprecated but kept for compatibility\r\n    public connect() {\r\n        // No-op: Socket is managed by socketService\r\n    }\r\n\r\n    public getSocket(): Socket {\r\n        return this.socket;\r\n    }\r\n\r\n    public subscribe(symbol: string, timeframe: string = \"M1\") {\r\n        symbol = symbol.trim();\r\n        timeframe = timeframe.trim();\r\n        // if (!this.socket) this.connect(); // Removed: Shared Socket is always present\r\n\r\n        // Store unique key for re-subscription\r\n        const key = `${symbol}|${timeframe}`;\r\n        this.subscribers.add(key);\r\n\r\n        if (this.socket?.connected) {\r\n            if (this.socket?.connected) {\r\n                // Send as separate arguments matching SocketServer handler\r\n                const traceId = `TRC-${Date.now()}-${Math.floor(Math.random() * 1000)}`;\r\n                console.log(`%c [Forensic] ${traceId} | 1. Frontend Emit | ${symbol} ${timeframe} | ${new Date().toISOString()}`, \"color: yellow; background: red; font-weight: bold;\");\r\n\r\n                // Pass TraceID as 3rd arg (Backend must update signature)\r\n                this.socket.emit(\"subscribe\", symbol, timeframe, traceId);\r\n            }\r\n        }\r\n    }\r\n\r\n    public unsubscribe(symbol: string, timeframe: string) {\r\n        const key = `${symbol}|${timeframe}`;\r\n        this.subscribers.delete(key);\r\n\r\n        if (this.socket?.connected) {\r\n            // Send as object to support granular unsubscribe in Backend\r\n            this.socket.emit(\"unsubscribe\", { symbol, timeframe });\r\n        }\r\n    }\r\n\r\n    public on(event: string, callback: (...args: any[]) => void) {\r\n        // Trace logging for specific events\r\n        if (event === 'bar_update') {\r\n            this.socket.on(event, (...args: any[]) => {\r\n                // TRACE POINT A\r\n                const payload = args[0];\r\n                if (payload && payload.symbol) {\r\n                    // console.log(`[CommunicationHub] TRACE A: Hub received Tick for ${payload.symbol} ${payload.timeframe}`);\r\n                }\r\n                callback(...args);\r\n            });\r\n        } else {\r\n            this.socket.on(event, callback);\r\n        }\r\n    }\r\n\r\n    public off(event: string, callback: (...args: any[]) => void) {\r\n        this.socket.off(event, callback);\r\n    }\r\n\r\n    public disconnect() {\r\n        // Do NOT disconnect shared socket.\r\n        // Only remove listeners if needed?\r\n        console.warn(\"[CommunicationHub] Disconnect called but ignored (Shared Socket)\");\r\n    }\r\n}\r\n\r\nexport const communicationHub = CommunicationHub.getInstance();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 352, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/services/DataSubscriptionOrchestrator.ts"],"sourcesContent":["\r\nimport { communicationHub } from \"./CommunicationHub\";\r\n\r\ntype SubscriptionKey = string; // Format: \"SYMBOL|TIMEFRAME\"\r\ntype PaneId = string;\r\n\r\nclass DataSubscriptionOrchestrator {\r\n    private static instance: DataSubscriptionOrchestrator;\r\n\r\n    // Map of active subscriptions: Key -> Map of PaneIDs to their Callbacks\r\n    private subscriptions: Map<SubscriptionKey, Map<PaneId, (bar: any) => void>> = new Map();\r\n\r\n    // Map of pending termination timeouts: Key -> Timeout ID\r\n    private pendingTerminations: Map<SubscriptionKey, NodeJS.Timeout> = new Map();\r\n\r\n    private readonly GRACE_PERIOD_MS = 10000;\r\n    private isVisible: boolean = true;\r\n    private visibilityDebounceTimer: NodeJS.Timeout | null = null;\r\n    private readonly VISIBILITY_DEBOUNCE_MS = 2000;\r\n\r\n    private constructor() {\r\n        if (typeof document !== 'undefined') {\r\n            this.isVisible = document.visibilityState === 'visible';\r\n            document.addEventListener('visibilitychange', this.handleVisibilityChange.bind(this));\r\n        }\r\n\r\n        // Trace Point B (Setup): Listening to Hub\r\n        // 4. Tick Relay: Listen to ALL bar updates globally\r\n        communicationHub.on('bar_update', this.onDataReceived.bind(this));\r\n    }\r\n\r\n    public static getInstance(): DataSubscriptionOrchestrator {\r\n        if (!DataSubscriptionOrchestrator.instance) {\r\n            DataSubscriptionOrchestrator.instance = new DataSubscriptionOrchestrator();\r\n        }\r\n        return DataSubscriptionOrchestrator.instance;\r\n    }\r\n\r\n    /**\r\n     * Ticks from Backend -> Orchestrator -> Many Subscribers\r\n     */\r\n    private onDataReceived(payload: any) {\r\n        // Trace Point B (Execution): Orchestrator received tick\r\n        // payload should have { symbol, timeframe, ...barData }\r\n        if (!payload || !payload.symbol || !payload.timeframe) return;\r\n        console.log(`[Orchestrator] Data received for ${payload.symbol} ${payload.timeframe}`);\r\n        const key = this.getKey(payload.symbol, payload.timeframe);\r\n        const subscribers = this.subscriptions.get(key);\r\n\r\n        if (subscribers && subscribers.size > 0) {\r\n            console.log(`[Orchestrator] TRACE B: Relaying tick for ${key} to ${subscribers.size} subscribers`);\r\n            subscribers.forEach((callback) => {\r\n                callback(payload);\r\n            });\r\n        } else {\r\n            console.warn(`[Orchestrator] TRACE C: Received tick for ${key} but NO subscribers found in Map! Keys:`, [...this.subscriptions.keys()]);\r\n        }\r\n    }\r\n\r\n    public subscribe(symbol: string, timeframe: string, paneId: PaneId, callback: (bar: any) => void) {\r\n        const key = this.getKey(symbol, timeframe);\r\n\r\n        // DIAGNOSTIC LOG (Task: Fix Over-Subscription)\r\n        console.log(`[Orchestrator] ðŸ“¥ SUBSCRIBE Request: ${key} [Pane: ${paneId}] (Visible: ${this.isVisible})`);\r\n\r\n        // 1. Cancel any pending termination for this key\r\n        if (this.pendingTerminations.has(key)) {\r\n            console.log(`[Orchestrator] â™»ï¸ Cancelled termination for ${key}`);\r\n            clearTimeout(this.pendingTerminations.get(key)!);\r\n            this.pendingTerminations.delete(key);\r\n        }\r\n\r\n        // 2. Add subscriber & callback\r\n        if (!this.subscriptions.has(key)) {\r\n            this.subscriptions.set(key, new Map());\r\n            // New stream needed\r\n            this.initiateStream(symbol, timeframe);\r\n        }\r\n\r\n        /* TRACE POINT C (Storage) */\r\n        this.subscriptions.get(key)!.set(paneId, callback);\r\n        console.log(`[Orchestrator] TRACE C: Stored callback for ${key} [Pane: ${paneId}]. Total subs: ${this.subscriptions.get(key)!.size}`);\r\n\r\n        // 3. Visibility Check logic\r\n        if (!this.isVisible) {\r\n            this.pauseStream(symbol, timeframe);\r\n        }\r\n    }\r\n\r\n    public unsubscribe(symbol: string, timeframe: string, paneId: PaneId) {\r\n        const key = this.getKey(symbol, timeframe);\r\n        const subscribers = this.subscriptions.get(key);\r\n\r\n        if (!subscribers) return;\r\n\r\n        console.log(`[Orchestrator] Unsubscribe Request: ${key} [Pane: ${paneId}]`);\r\n\r\n        subscribers.delete(paneId);\r\n\r\n        if (subscribers.size === 0) {\r\n            // No more subscribers - Start Grace Period\r\n            console.log(`[Orchestrator] â³ Starting Grace Period for ${key} (${this.GRACE_PERIOD_MS}ms)`);\r\n\r\n            const timeout = setTimeout(() => {\r\n                this.terminateStream(symbol, timeframe);\r\n            }, this.GRACE_PERIOD_MS);\r\n\r\n            this.pendingTerminations.set(key, timeout);\r\n        }\r\n    }\r\n\r\n    private initiateStream(symbol: string, timeframe: string) {\r\n        console.log(`[Orchestrator] ðŸš€ Initiating Stream: ${symbol} ${timeframe}`);\r\n        communicationHub.subscribe(symbol, timeframe);\r\n    }\r\n\r\n    private terminateStream(symbol: string, timeframe: string) {\r\n        const key = this.getKey(symbol, timeframe);\r\n\r\n        // Double check no one re-subscribed in the meantime\r\n        if (this.subscriptions.has(key) && this.subscriptions.get(key)!.size > 0) {\r\n            console.warn(`[Orchestrator] âš ï¸ Termination aborted, active subscribers found for ${key}`);\r\n            return;\r\n        }\r\n\r\n        console.log(`[Orchestrator] ðŸ›‘ Terminating Stream: ${symbol} ${timeframe}`);\r\n        communicationHub.unsubscribe(symbol, timeframe);\r\n        this.subscriptions.delete(key);\r\n        this.pendingTerminations.delete(key);\r\n    }\r\n\r\n    private pauseStream(symbol: string, timeframe: string) {\r\n        const socket = communicationHub.getSocket();\r\n        if (socket?.connected) {\r\n            console.log(`[Orchestrator] â¸ï¸ Pausing Stream: ${symbol} ${timeframe}`);\r\n            socket.emit('pause_stream', { symbol, timeframe });\r\n        }\r\n    }\r\n\r\n    private resumeStream(symbol: string, timeframe: string) {\r\n        const socket = communicationHub.getSocket();\r\n        if (socket?.connected) {\r\n            console.log(`[Orchestrator] â–¶ï¸ Resuming Stream: ${symbol} ${timeframe}`);\r\n            socket.emit('resume_stream', { symbol, timeframe });\r\n        }\r\n    }\r\n\r\n    private handleVisibilityChange() {\r\n        const currentlyVisible = document.visibilityState === 'visible';\r\n        console.log(`[Orchestrator] Visibility Event: ${currentlyVisible ? 'VISIBLE' : 'HIDDEN'}`);\r\n\r\n        if (this.visibilityDebounceTimer) {\r\n            clearTimeout(this.visibilityDebounceTimer);\r\n            this.visibilityDebounceTimer = null;\r\n        }\r\n\r\n        if (currentlyVisible) {\r\n            if (!this.isVisible) {\r\n                this.isVisible = true;\r\n                this.subscriptions.forEach((_, key) => {\r\n                    const [symbol, timeframe] = this.decodeKey(key);\r\n                    this.resumeStream(symbol, timeframe);\r\n                });\r\n            } else {\r\n                console.log(`[Orchestrator] ðŸ™ˆ Quick toggle detected, staying VISIBLE.`);\r\n            }\r\n        } else {\r\n            this.visibilityDebounceTimer = setTimeout(() => {\r\n                this.isVisible = false;\r\n                console.log(`[Orchestrator] ðŸŒ‘ Debounce elapsed. Throttling streams.`);\r\n                this.subscriptions.forEach((_, key) => {\r\n                    const [symbol, timeframe] = this.decodeKey(key);\r\n                    this.pauseStream(symbol, timeframe);\r\n                });\r\n            }, this.VISIBILITY_DEBOUNCE_MS);\r\n        }\r\n    }\r\n\r\n    private getKey(symbol: string, timeframe: string): string {\r\n        return `${symbol.trim()}|${timeframe.trim()}`;\r\n    }\r\n\r\n    private decodeKey(key: string): [string, string] {\r\n        const parts = key.split('|');\r\n        return [parts[0], parts[1]];\r\n    }\r\n}\r\n\r\nexport const dataSubscriptionOrchestrator = DataSubscriptionOrchestrator.getInstance();\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 524, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/services/MT5Datafeed.ts"],"sourcesContent":["import { communicationHub } from \"./CommunicationHub\";\r\nimport { sendCommand, fetchMessages } from \"./api\";\r\nimport { dataSubscriptionOrchestrator } from \"./DataSubscriptionOrchestrator\";\r\n\r\n// Basic interface for TradingView Datafeed (subset)\r\nexport interface IDatafeed {\r\n    onReady: (callback: (config: any) => void) => void;\r\n    searchSymbols: (userInput: string, exchange: string, symbolType: string, onResult: (result: any[]) => void) => void;\r\n    resolveSymbol: (symbolName: string, onSymbolResolvedCallback: (symbolInfo: any) => void, onResolveErrorCallback: (reason: string) => void) => void;\r\n    getBars: (symbolInfo: any, resolution: string, periodParams: any, onHistoryCallback: (bars: any[], meta: any) => void, onErrorCallback: (error: string) => void) => void;\r\n    subscribeBars: (symbolInfo: any, resolution: string, onRealtimeCallback: (bar: any) => void, subscribeUID: string, onResetCacheNeededCallback: () => void) => void;\r\n    unsubscribeBars: (subscriberUID: string) => void;\r\n}\r\n\r\nexport class MT5Datafeed implements IDatafeed {\r\n    private subscriptions: Map<string, any> = new Map();\r\n    private availableSymbols: string[] = [];\r\n\r\n    private initializationPromise: Promise<void>;\r\n    private initializationResolver: () => void = () => { };\r\n\r\n    constructor() {\r\n        // Initialize the promise immediately\r\n        this.initializationPromise = new Promise((resolve) => {\r\n            this.initializationResolver = resolve;\r\n        });\r\n\r\n        // Ensure hub is connected\r\n        communicationHub.connect();\r\n        this.loadSymbols();\r\n    }\r\n\r\n    private async loadSymbols() {\r\n        try {\r\n            const res = await fetch('http://localhost:3005/api/mappings');\r\n            if (res.ok) {\r\n                const mappings = await res.json();\r\n                // We only care about the \"Frontend Name\" (Original Symbol or Fallback)\r\n                // We do NOT care about BotIDs or Datafeed Symbols here.\r\n                this.availableSymbols = mappings.map((m: any) => m.originalSymbol || m.datafeedSymbol).filter(Boolean);\r\n\r\n                // Deduplicate\r\n                this.availableSymbols = [...new Set(this.availableSymbols)];\r\n\r\n                console.log(`[MT5Datafeed] Loaded ${this.availableSymbols.length} symbols.`);\r\n            }\r\n        } catch (e) {\r\n            console.error(\"[MT5Datafeed] Failed to load symbols\", e);\r\n        } finally {\r\n            // ALWAYS resolve, even on error, so we don't block forever\r\n            this.initializationResolver();\r\n        }\r\n    }\r\n\r\n    onReady(callback: (config: any) => void): void {\r\n        console.log(\"%c [MT5Datafeed] VERSION 4.2: ORCHESTRATED (ASYNC INIT)\", \"color: magenta; font-weight: bold; font-size: 14px;\");\r\n        setTimeout(() => callback({\r\n            supported_resolutions: ['1', '5', '15', '30', '60', '240', 'D', 'W', 'M'],\r\n            supports_marks: false,\r\n            supports_timescale_marks: false,\r\n            supports_time: true,\r\n        }), 0);\r\n    }\r\n\r\n    async searchSymbols(userInput: string, exchange: string, symbolType: string, onResult: (result: any[]) => void): Promise<void> {\r\n        await this.initializationPromise;\r\n\r\n        const query = userInput.toLowerCase();\r\n        const matches = this.availableSymbols.filter(s => s.toLowerCase().includes(query));\r\n\r\n        if (matches.length > 0) {\r\n            onResult(matches.map(s => ({\r\n                symbol: s,\r\n                full_name: s,\r\n                description: s,\r\n                exchange: \"Broker\",\r\n                type: \"currency\"\r\n            })));\r\n        } else {\r\n            // Fallback: Allow user to type anything (maybe they added a sym but didn't refresh)\r\n            onResult([\r\n                { symbol: userInput, full_name: userInput, description: userInput, exchange: \"Forex\", type: \"currency\" }\r\n            ]);\r\n        }\r\n    }\r\n\r\n    async resolveSymbol(symbolName: string, onSymbolResolvedCallback: (symbolInfo: any) => void, onResolveErrorCallback: (reason: string) => void): Promise<void> {\r\n        await this.initializationPromise;\r\n\r\n        console.log(`[MT5Datafeed] ðŸ” Resolving Symbol: ${symbolName}`);\r\n        const info = {\r\n            name: symbolName,\r\n            full_name: symbolName,\r\n            description: symbolName,\r\n            type: 'forex',\r\n            session: '24x7',\r\n            timezone: 'Etc/UTC',\r\n            exchange: 'Forex',\r\n            minmov: 1,\r\n            pricescale: 100000,\r\n            has_intraday: true,\r\n            has_no_volume: false,\r\n            has_weekly_and_monthly: true,\r\n            supported_resolutions: ['1', '5', '15', '30', '60', '240', 'D', 'W', 'M'],\r\n            volume_precision: 2,\r\n            data_status: 'streaming',\r\n        };\r\n        setTimeout(() => onSymbolResolvedCallback(info), 0);\r\n    }\r\n\r\n    private lastBarTimes: Map<string, number> = new Map();\r\n    private lastBars: Map<string, any> = new Map(); // Cache for Open Price Locking\r\n\r\n    async getBars(symbolInfo: any, resolution: string, periodParams: any, onHistoryCallback: (bars: any[], meta: any) => void, onErrorCallback: (error: string) => void): Promise<void> {\r\n        // Wait for initialization before asking for history\r\n        await this.initializationPromise;\r\n\r\n        const { from, to, countBack, firstDataRequest } = periodParams;\r\n        const tf = this.resolutionToTimeframe(resolution);\r\n        const symbol = symbolInfo.name;\r\n\r\n        if (!firstDataRequest) {\r\n            console.log(`%c [MT5Datafeed] (a) SCROLL DETECTED | (b) NEED HISTORY | To: ${to} (${new Date(to * 1000).toISOString()})`, \"color: cyan; font-weight: bold; background: #333; padding: 4px;\");\r\n        } else {\r\n            console.log(`%c >>> GETBARS START: ${symbol} ${resolution} <<<`, \"background: red; color: white;\");\r\n        }\r\n\r\n        try {\r\n            // Safety check\r\n            if (this.availableSymbols.length === 0) {\r\n                console.warn(\"[MT5Datafeed] availableSymbols is empty after init. Possible startup issue.\");\r\n            }\r\n\r\n            // USER OVERRIDE: 20k is too heavy for First Load (>10MB JSON). \r\n            // Start light (1k) to get Chart visible instantly. Pagination fills the rest.\r\n            const reqLimit = firstDataRequest ? 1000 : 20000;\r\n\r\n            let url = `http://127.0.0.1:3005/history?symbol=${symbol}&timeframe=${tf}&limit=${reqLimit}`;\r\n            if (!firstDataRequest && to) {\r\n                // Pagination: Load OLDER than 'to'\r\n                url += `&to=${Math.floor(to * 1000)}`;\r\n            }\r\n            // Cache Buster\r\n            url += `&_=${Date.now()}`;\r\n\r\n            console.log(`[MT5Datafeed] (c) LOADING HISTORY: ${url}`);\r\n            const res = await fetch(url);\r\n\r\n            if (!res.ok) {\r\n                console.error(\"[MT5Datafeed] API Status Error:\", res.status);\r\n                onHistoryCallback([], { noData: true });\r\n                return;\r\n            }\r\n\r\n            const data = await res.json();\r\n            const count = data.candles?.length || 0;\r\n            console.log(`%c [MT5Datafeed] (d) HISTORY RESULT: Received ${count} candles.`, count === 0 ? \"color: red; font-weight: bold;\" : \"color: lime;\");\r\n\r\n            if (data.success && data.candles && count > 0) {\r\n                // ... Mapping Logik ...\r\n                const bars = data.candles.map((c: any) => {\r\n                    // Universal Timestamp Fix: Support both Sec and MS\r\n                    let t = Number(c.time);\r\n                    if (t > 100000000000) {\r\n                        t = t / 1000; // Convert MS to Sec\r\n                    }\r\n                    return {\r\n                        time: t,\r\n                        open: c.open,\r\n                        high: c.high,\r\n                        low: c.low,\r\n                        close: c.close,\r\n                        volume: c.volume || 0\r\n                    };\r\n                });\r\n\r\n                // Sorting is crucial\r\n                bars.sort((a: any, b: any) => a.time - b.time);\r\n\r\n                // MERGE LIVE CACHE (Fix for Flicker on Reset)\r\n                const cacheKey = `${symbol}_${tf}`;\r\n                const cachedBar = this.lastBars.get(cacheKey);\r\n                if (cachedBar) {\r\n                    const lastFetched = bars[bars.length - 1];\r\n                    // If cached bar is newer or same time (Live is authoritative)\r\n                    if (!lastFetched || cachedBar.time > lastFetched.time) {\r\n                        bars.push(cachedBar);\r\n                        // console.log(`[MT5Datafeed] ðŸ”— Appended Live Bar to History: ${cachedBar.time}`);\r\n                    } else if (cachedBar.time === lastFetched.time) {\r\n                        bars[bars.length - 1] = cachedBar;\r\n                        // console.log(`[MT5Datafeed] ðŸ”— Overwrote Stale History with Live Bar: ${cachedBar.time}`);\r\n                    }\r\n                }\r\n\r\n                const lastBar = bars[bars.length - 1];\r\n                if (lastBar) {\r\n                    const currentLast = this.lastBarTimes.get(cacheKey) || 0;\r\n                    if (lastBar.time > currentLast) {\r\n                        this.lastBarTimes.set(cacheKey, lastBar.time);\r\n                    }\r\n                }\r\n\r\n                onHistoryCallback(bars, { noData: false });\r\n            } else {\r\n                if (!firstDataRequest) {\r\n                    // PENDING STATE: API gave 0 candles during pagination.\r\n                    // The backend might be busy fetching from broker.\r\n                    // We send 'noData: false' with empty array to tell TV to retry.\r\n                    // Refined Logic per User: \"noData: true ONLY IF ... Backend confirms end\".\r\n                    // For now, if we don't have explicit end flag, we assume PENDING.\r\n                    console.log(\"[MT5Datafeed] Pagination empty (Pending?). Sending noData: false to trigger retry.\");\r\n                    onHistoryCallback([], { noData: false });\r\n                } else {\r\n                    console.log(\"[MT5Datafeed] First Load empty. Sending noData: true.\");\r\n                    onHistoryCallback([], { noData: true });\r\n                }\r\n            }\r\n        } catch (e) {\r\n            console.error(\"[MT5Datafeed] FATAL ERROR in getBars:\", e);\r\n            onErrorCallback(\"Crash\");\r\n        }\r\n    }\r\n\r\n    subscribeBars(symbolInfo: any, resolution: string, onRealtimeCallback: (bar: any) => void, subscribeUID: string, onResetCacheNeededCallback: () => void): void {\r\n        const symbol = symbolInfo.name.trim(); // PURE SYMBOL\r\n        const expectedTf = this.resolutionToTimeframe(resolution).trim();\r\n\r\n        console.log(`[MT5Datafeed] Subscribe Realtime: ${symbol} [${subscribeUID} / TF: ${expectedTf}]`);\r\n\r\n        const periodMs = this.resolutionToMs(resolution);\r\n        const periodSec = periodMs / 1000;\r\n\r\n        // Callback wrapped to process raw data from Orchestrator\r\n        const orchestratedListener = (candle: any) => {\r\n            // Check match - redundant if orchestrator does its job, but safe.\r\n            console.log(`[MT5Datafeed] TRACE D: orchestratedListener for ${symbol} ${expectedTf} received data for ${candle.symbol} ${candle.timeframe}`);\r\n            let rawTime = candle.time;\r\n            if (rawTime > 100000000000) rawTime = rawTime / 1000;\r\n\r\n            const alignedTimeSec = Math.floor(rawTime / periodSec) * periodSec;\r\n            const timeSec = alignedTimeSec;\r\n\r\n            // GAP & ORDER DETECTION\r\n            const key = `${symbol}_${expectedTf}`;\r\n            const lastTime = this.lastBarTimes.get(key);\r\n            let cachedBar = this.lastBars.get(key);\r\n\r\n            if (lastTime) {\r\n                if (timeSec < lastTime) {\r\n                    console.warn(`[MT5Datafeed] ðŸ“‰ Stale Update (History?) Ignored. Bar: ${timeSec}, Last: ${lastTime}`);\r\n                    return;\r\n                }\r\n                if (timeSec > (lastTime + periodSec + 1)) {\r\n                    console.warn(`[MT5Datafeed] âš ï¸ Gap Detected! Last: ${lastTime}, New: ${timeSec}. Resetting.`);\r\n                    onResetCacheNeededCallback();\r\n                    this.lastBarTimes.set(key, timeSec);\r\n                    this.lastBars.delete(key);\r\n                    return;\r\n                }\r\n            }\r\n            this.lastBarTimes.set(key, timeSec);\r\n\r\n            // STABILITY FIX: Lock Open Price for the same bar\r\n            let openPrice = candle.open;\r\n            if (cachedBar && cachedBar.time === timeSec) {\r\n                // If we already have a bar for this time, keep the INITIAL Open.\r\n                // This prevents \"Jumping Open\" if the backend sends glitches or undefined.\r\n                if (cachedBar.open) {\r\n                    if (Math.abs(cachedBar.open - candle.open) > 0.0000001) {\r\n                        console.warn(`[MT5Datafeed] ðŸ”’ Locking Open: ${cachedBar.open} (Ignoring New: ${candle.open})`);\r\n                    }\r\n                    openPrice = cachedBar.open;\r\n                }\r\n            } else {\r\n                console.log(`[MT5Datafeed] ðŸ†• New Bar or Reset. Open: ${openPrice} Time: ${timeSec} (Last: ${this.lastBarTimes.get(key)})`);\r\n            }\r\n\r\n            const barToEmit = {\r\n                symbol: symbol,\r\n                timeframe: expectedTf,\r\n                time: timeSec,\r\n                open: openPrice,\r\n                high: candle.high,\r\n                low: candle.low,\r\n                close: candle.close,\r\n                volume: candle.volume\r\n            };\r\n\r\n            // Update Cache\r\n            this.lastBars.set(key, barToEmit);\r\n\r\n            // DEBUG: Trace Fidelity\r\n            // console.log(`[MT5Datafeed] ðŸ“Š Live Update ${symbol} [${new Date(timeSec * 1000).toISOString().split('T')[1]}] | O:${barToEmit.open} H:${barToEmit.high} L:${barToEmit.low} C:${barToEmit.close}`);\r\n\r\n            onRealtimeCallback(barToEmit);\r\n        };\r\n\r\n        // Use Orchestrator to manage subscription lifecycle AND distribution\r\n        // subscribeUID serves as the paneId. Pass the listener to be registered.\r\n        dataSubscriptionOrchestrator.subscribe(symbol, expectedTf, subscribeUID, orchestratedListener);\r\n\r\n        const historyListener = (data: any) => {\r\n            if (data.symbol === symbol && data.timeframe === expectedTf) {\r\n                console.log(`[MT5Datafeed] History Update detected for ${symbol}. Resetting Cache.`);\r\n                onResetCacheNeededCallback();\r\n            }\r\n        };\r\n\r\n        // History updates: We still listen directly for now unless moved to Orchestrator later\r\n        communicationHub.on('history_update', historyListener);\r\n\r\n        this.subscriptions.set(subscribeUID, {\r\n            symbol: symbol,\r\n            orchestratedListener: orchestratedListener,\r\n            historyListener: historyListener,\r\n            timeframe: expectedTf\r\n        });\r\n    }\r\n\r\n    unsubscribeBars(subscriberUID: string): void {\r\n        const sub = this.subscriptions.get(subscriberUID);\r\n        if (sub) {\r\n            console.log(`[MT5Datafeed] Unsubscribe: ${sub.symbol} [${subscriberUID}]`);\r\n\r\n            // Remove local listeners\r\n            // communicationHub.off('bar_update', sub.listener); // Removed, handled by orchestrator\r\n            if (sub.historyListener) {\r\n                communicationHub.off('history_update', sub.historyListener);\r\n            }\r\n\r\n            // Tell Orchestrator to release this subscription\r\n            dataSubscriptionOrchestrator.unsubscribe(sub.symbol, sub.timeframe, subscriberUID);\r\n\r\n            this.subscriptions.delete(subscriberUID);\r\n        }\r\n    }\r\n\r\n    private resolutionToTimeframe(resolution: string): string {\r\n        const tfMap: Record<string, string> = {\r\n            '1': 'M1', '2': 'M2', '3': 'M3', '4': 'M4', '5': 'M5', '6': 'M6', '10': 'M10', '12': 'M12', '15': 'M15', '20': 'M20', '30': 'M30',\r\n            '60': 'H1', '120': 'H2', '180': 'H3', '240': 'H4', '360': 'H6', '480': 'H8', '720': 'H12',\r\n            'D': 'D1', '1D': 'D1', 'W': 'W1', '1W': 'W1', 'M': 'MN1', '1M': 'MN1',\r\n            // Passthrough\r\n            'M1': 'M1', 'M2': 'M2', 'M3': 'M3', 'M4': 'M4', 'M5': 'M5', 'M6': 'M6', 'M10': 'M10', 'M12': 'M12', 'M15': 'M15', 'M20': 'M20', 'M30': 'M30',\r\n            'H1': 'H1', 'H2': 'H2', 'H3': 'H3', 'H4': 'H4', 'H6': 'H6', 'H8': 'H8', 'H12': 'H12',\r\n            'D1': 'D1', 'W1': 'W1', 'MN1': 'MN1'\r\n        };\r\n        return tfMap[resolution] || 'H1';\r\n    }\r\n\r\n    private resolutionToMs(res: string): number {\r\n        if (res.startsWith('M')) {\r\n            if (res === 'MN1') return 30 * 24 * 60 * 60 * 1000;\r\n            const min = parseInt(res.substring(1));\r\n            return (isNaN(min) ? 1 : min) * 60 * 1000;\r\n        }\r\n        if (res.startsWith('H')) {\r\n            const hour = parseInt(res.substring(1));\r\n            return (isNaN(hour) ? 1 : hour) * 60 * 60 * 1000;\r\n        }\r\n        if (res.startsWith('D')) return 24 * 60 * 60 * 1000;\r\n        if (res.startsWith('W') || res === 'W1') return 7 * 24 * 60 * 60 * 1000;\r\n        if (res === 'MN1' || res === 'M' || res === '1M') return 30 * 24 * 60 * 60 * 1000;\r\n\r\n        const val = parseInt(res);\r\n        if (isNaN(val)) return 60000;\r\n        return val * 60 * 1000;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 919, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/utils/chartUtils.ts"],"sourcesContent":["\r\nexport type Timeframe = 'M1' | 'M2' | 'M3' | 'M5' | 'M10' | 'M15' | 'M30' | 'H1' | 'H2' | 'H3' | 'H4' | 'H6' | 'H8' | 'H12' | 'D1' | 'W1' | 'MN1';\r\n\r\nexport const getTimeframeSeconds = (tf: string): number => {\r\n    switch (tf) {\r\n        case 'M1': return 60;\r\n        case 'M2': return 120;\r\n        case 'M3': return 180;\r\n        case 'M5': return 300;\r\n        case 'M10': return 600;\r\n        case 'M15': return 900;\r\n        case 'M30': return 1800;\r\n        case 'H1': return 3600;\r\n        case 'H2': return 7200;\r\n        case 'H3': return 10800;\r\n        case 'H4': return 14400;\r\n        case 'H6': return 21600;\r\n        case 'H8': return 28800;\r\n        case 'H12': return 43200;\r\n        case 'D1': return 86400;\r\n        case 'W1': return 604800;\r\n        case 'MN1': return 2592000;\r\n        default: return 60;\r\n    }\r\n};\r\n\r\n\r\nexport const generatePhantomBars = (lastRealTime: number, basePrice: number, timeframe: string, minCount: number = 200): { time: number, value: number }[] => {\r\n    const interval = getTimeframeSeconds(timeframe);\r\n    const phantoms: { time: number; value: number }[] = [];\r\n\r\n    // ROLLBACK & OPTIMIZE:\r\n    // User requested rollback to Phantom Bars for stability.\r\n    // Optimization: Use fixed limit (200) instead of infinite (10000) to prevent \"Zoom to 2026\" issue.\r\n    const limit = minCount;\r\n\r\n    let currentTime = lastRealTime;\r\n    for (let i = 0; i < limit; i++) {\r\n        currentTime += interval;\r\n        phantoms.push({ time: currentTime, value: basePrice });\r\n    }\r\n\r\n    return phantoms;\r\n};\r\n"],"names":[],"mappings":";;;;;;AAGO,MAAM,sBAAsB,CAAC;IAChC,OAAQ;QACJ,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAO,OAAO;QACnB,KAAK;YAAO,OAAO;QACnB,KAAK;YAAO,OAAO;QACnB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAO,OAAO;QACnB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAM,OAAO;QAClB,KAAK;YAAO,OAAO;QACnB;YAAS,OAAO;IACpB;AACJ;AAGO,MAAM,sBAAsB,CAAC,cAAsB,WAAmB,WAAmB,WAAmB,GAAG;IAClH,MAAM,WAAW,oBAAoB;IACrC,MAAM,WAA8C,EAAE;IAEtD,uBAAuB;IACvB,yDAAyD;IACzD,mGAAmG;IACnG,MAAM,QAAQ;IAEd,IAAI,cAAc;IAClB,IAAK,IAAI,IAAI,GAAG,IAAI,OAAO,IAAK;QAC5B,eAAe;QACf,SAAS,IAAI,CAAC;YAAE,MAAM;YAAa,OAAO;QAAU;IACxD;IAEA,OAAO;AACX"}},
    {"offset": {"line": 989, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/context/ChartThemeContext.tsx"],"sourcesContent":["\"use client\";\r\n\r\nimport React, { createContext, useContext, useEffect, useState } from \"react\";\r\nimport { useTheme } from \"./ThemeProvider\";\r\n\r\n// --- THEME DEFINITIONS ---\r\n\r\nexport interface ChartTheme {\r\n    layout: {\r\n        background: { type: string; color: string } | string; // Support legacy string\r\n        textColor: string;\r\n    };\r\n    grid: {\r\n        vertLines: { color: string; visible: boolean; style: number };\r\n        horzLines: { color: string; visible: boolean; style: number };\r\n    };\r\n    candles: {\r\n        upColor: string;\r\n        downColor: string;\r\n        borderUpColor: string;\r\n        borderDownColor: string;\r\n        wickUpColor: string;\r\n        wickDownColor: string;\r\n    };\r\n    crosshair: {\r\n        color: string;\r\n    };\r\n    timeScale: {\r\n        borderColor: string;\r\n    };\r\n    priceScale: {\r\n        borderColor: string;\r\n    };\r\n}\r\n\r\nexport const DEFAULT_THEME: ChartTheme = {\r\n    layout: {\r\n        background: { type: 'solid', color: '#131722' },\r\n        textColor: '#d1d4dc',\r\n    },\r\n    grid: {\r\n        vertLines: { color: '#1e222d', visible: true, style: 0 },\r\n        horzLines: { color: '#1e222d', visible: true, style: 0 },\r\n    },\r\n    candles: {\r\n        upColor: '#089981',\r\n        downColor: '#f23645',\r\n        borderUpColor: '#089981',\r\n        borderDownColor: '#f23645',\r\n        wickUpColor: '#089981',\r\n        wickDownColor: '#f23645',\r\n    },\r\n    crosshair: {\r\n        color: '#758696',\r\n    },\r\n    timeScale: {\r\n        borderColor: '#2B2B43',\r\n    },\r\n    priceScale: {\r\n        borderColor: '#2B2B43',\r\n    }\r\n};\r\n\r\nexport const DEFAULT_LIGHT_THEME: ChartTheme = {\r\n    layout: {\r\n        background: { type: 'solid', color: '#ffffff' },\r\n        textColor: '#1e293b', // slate-800\r\n    },\r\n    grid: {\r\n        vertLines: { color: '#e2e8f0', visible: true, style: 0 }, // slate-200\r\n        horzLines: { color: '#e2e8f0', visible: true, style: 0 },\r\n    },\r\n    candles: {\r\n        upColor: '#089981',\r\n        downColor: '#ef4444', // red-500\r\n        borderUpColor: '#089981',\r\n        borderDownColor: '#ef4444',\r\n        wickUpColor: '#089981',\r\n        wickDownColor: '#ef4444',\r\n    },\r\n    crosshair: {\r\n        color: '#94a3b8', // slate-400\r\n    },\r\n    timeScale: {\r\n        borderColor: '#e2e8f0',\r\n    },\r\n    priceScale: {\r\n        borderColor: '#e2e8f0',\r\n    }\r\n};\r\n\r\n// --- UTILS ---\r\n\r\n/**\r\n * Deep merges source object into target object.\r\n * Returns a new object.\r\n */\r\nfunction deepMerge(target: any, source: any): any {\r\n    if (typeof target !== 'object' || target === null) {\r\n        return source;\r\n    }\r\n\r\n    const output = { ...target };\r\n\r\n    if (isObject(target) && isObject(source)) {\r\n        Object.keys(source).forEach(key => {\r\n            if (isObject(source[key])) {\r\n                if (!(key in target)) {\r\n                    Object.assign(output, { [key]: source[key] });\r\n                } else {\r\n                    output[key] = deepMerge(target[key], source[key]);\r\n                }\r\n            } else {\r\n                Object.assign(output, { [key]: source[key] });\r\n            }\r\n        });\r\n    }\r\n\r\n    return output;\r\n}\r\n\r\nfunction isObject(item: any) {\r\n    return (item && typeof item === 'object' && !Array.isArray(item));\r\n}\r\n\r\n/**\r\n * Migrates legacy theme structures to the current schema.\r\n */\r\nfunction migrateTheme(savedCallback: any): ChartTheme {\r\n    let migrated = { ...DEFAULT_THEME };\r\n\r\n    // 1. Deep merge saved data onto default to fill missing top-level keys\r\n    // This handles the case where 'crosshair' was missing in saved data\r\n    migrated = deepMerge(migrated, savedCallback);\r\n\r\n    // 2. Handle specific migrations (String Grid -> Object Grid)\r\n    if (migrated.grid) {\r\n        // Fix VertLines\r\n        if (typeof migrated.grid.vertLines === 'string') {\r\n            migrated.grid.vertLines = {\r\n                color: migrated.grid.vertLines,\r\n                visible: true,\r\n                style: 0\r\n            };\r\n        }\r\n        // Fix HorzLines\r\n        if (typeof migrated.grid.horzLines === 'string') {\r\n            migrated.grid.horzLines = {\r\n                color: migrated.grid.horzLines,\r\n                visible: true,\r\n                style: 0\r\n            };\r\n        }\r\n    }\r\n\r\n    // 3. Fix Layout Background (String -> Object)\r\n    if (migrated.layout && typeof migrated.layout.background === 'string') {\r\n        migrated.layout.background = { type: 'solid', color: migrated.layout.background };\r\n    }\r\n\r\n    return migrated;\r\n}\r\n\r\n\r\n// --- CONTEXT ---\r\n\r\n// --- CONTEXT ---\r\n\r\ninterface ChartThemeContextType {\r\n    theme: ChartTheme;\r\n    mode: 'light' | 'dark'; // Track the mode explicitly\r\n    setMode: (mode: 'light' | 'dark') => void;\r\n    updateTheme: (newTheme: Partial<ChartTheme>) => void;\r\n    resetTheme: () => void;\r\n}\r\n\r\nconst ChartThemeContext = createContext<ChartThemeContextType | undefined>(undefined);\r\n\r\nexport const ChartThemeProvider = ({ children }: { children: React.ReactNode }) => {\r\n    // We NO LONGER sync with global theme automatically unless requested.\r\n    // Default to LIGHT as per user request.\r\n    const [mode, setMode] = useState<'light' | 'dark'>('light');\r\n    const [theme, setTheme] = useState<ChartTheme>(DEFAULT_LIGHT_THEME);\r\n    const [mounted, setMounted] = useState(false);\r\n\r\n    // Persist Mode\r\n    useEffect(() => {\r\n        if (!mounted) return;\r\n        localStorage.setItem(\"chart_theme_mode\", mode);\r\n        // Apply base theme for the mode\r\n        if (mode === 'light') {\r\n            setTheme(DEFAULT_LIGHT_THEME);\r\n        } else {\r\n            setTheme(DEFAULT_THEME);\r\n        }\r\n    }, [mode, mounted]);\r\n\r\n    // Load from LocalStorage on mount\r\n    useEffect(() => {\r\n        setMounted(true);\r\n        // Load Mode\r\n        const savedMode = localStorage.getItem(\"chart_theme_mode\") as 'light' | 'dark';\r\n        if (savedMode && (savedMode === 'light' || savedMode === 'dark')) {\r\n            setMode(savedMode);\r\n        } else {\r\n            setMode('light'); // Default to light\r\n        }\r\n\r\n        // Load Custom Overrides (optional, if we still want to support custom theme tweaks on top of base)\r\n        const savedTheme = localStorage.getItem(\"chart_theme\");\r\n        if (savedTheme) {\r\n            try {\r\n                const parsed = JSON.parse(savedTheme);\r\n                const validTheme = migrateTheme(parsed);\r\n                // We should probably merge this ON TOP of the base theme for the current mode\r\n                // But for now, let's just respect the mode switch primarily.\r\n                // If specific overrides exist, they might be mode-specific... simplified for now:\r\n                // If user toggles mode, we reset customizations? Or do we keep them?\r\n                // User asked for \"Light or Dark\", simple. Let's prioritize the Mode.\r\n            } catch (e) {\r\n                console.error(\"Failed to load theme\", e);\r\n            }\r\n        }\r\n    }, []);\r\n\r\n    const updateTheme = (newTheme: any) => {\r\n        setTheme(prev => {\r\n            const updated = deepMerge(prev, newTheme);\r\n            localStorage.setItem(\"chart_theme\", JSON.stringify(updated));\r\n            return updated;\r\n        });\r\n    };\r\n\r\n    const resetTheme = () => {\r\n        setMode('light');\r\n        setTheme(DEFAULT_LIGHT_THEME);\r\n        localStorage.removeItem(\"chart_theme\");\r\n        localStorage.removeItem(\"chart_theme_mode\");\r\n    };\r\n\r\n    return (\r\n        <ChartThemeContext.Provider value={{ theme, mode, setMode, updateTheme, resetTheme }}>\r\n            {children}\r\n        </ChartThemeContext.Provider>\r\n    );\r\n};\r\n\r\nexport const useChartTheme = () => {\r\n    const context = useContext(ChartThemeContext);\r\n    if (!context) throw new Error(\"useChartTheme must be used within a ChartThemeProvider\");\r\n    return context;\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1249, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/hooks/useContextMenu.ts"],"sourcesContent":["import { useState, useCallback, useEffect } from 'react';\r\nimport { ChartWidget } from '../components/charts/widgets/ChartWidget';\r\nimport { SettingField, InteractiveChartObject } from '../components/charts/widgets/InteractiveChartObject';\r\nimport { IChartShape } from '../components/charts/widgets/api';\r\n\r\nexport interface ContextMenuState {\r\n    visible: boolean;\r\n    x: number;\r\n    y: number;\r\n    type: 'widget' | 'global';\r\n    targetId?: string; // For widget menu\r\n}\r\n\r\nexport interface SettingsState {\r\n    isOpen: boolean;\r\n    schema: SettingField[];\r\n    targetShape: IChartShape | null;\r\n}\r\n\r\nexport const useContextMenu = (\r\n    containerRef: React.RefObject<HTMLDivElement | null>,\r\n    chartWidgetRef: React.MutableRefObject<ChartWidget | null>\r\n) => {\r\n    const [menuState, setMenuState] = useState<ContextMenuState>({ visible: false, x: 0, y: 0, type: 'global' });\r\n    const [settingsState, setSettingsState] = useState<SettingsState>({ isOpen: false, schema: [], targetShape: null });\r\n\r\n    const handleContextMenu = useCallback((e: MouseEvent) => {\r\n        e.preventDefault();\r\n\r\n        if (!containerRef.current || !chartWidgetRef.current) return;\r\n\r\n        // 1. Coordinate Translation\r\n        const rect = containerRef.current.getBoundingClientRect();\r\n        const x = e.clientX - rect.left;\r\n        const y = e.clientY - rect.top;\r\n\r\n        // 2. Hit Test\r\n        // Note: chartWidgetRef.current.hitTest must iterate in reverse order\r\n        const hitShape = chartWidgetRef.current.hitTest(x, y);\r\n\r\n        if (hitShape) {\r\n            // Scenario A: Widget Clicked\r\n            setMenuState({\r\n                visible: true,\r\n                x: e.clientX, // Screen coords for menu fixed position\r\n                y: e.clientY,\r\n                type: 'widget',\r\n                targetId: hitShape.id\r\n            });\r\n        } else {\r\n            // Scenario B: Empty Space Clicked\r\n            setMenuState({\r\n                visible: true,\r\n                x: e.clientX,\r\n                y: e.clientY,\r\n                type: 'global'\r\n            });\r\n        }\r\n    }, [containerRef, chartWidgetRef]);\r\n\r\n    // Attach listener\r\n    useEffect(() => {\r\n        const container = containerRef.current;\r\n        if (!container) return;\r\n\r\n        container.addEventListener('contextmenu', handleContextMenu);\r\n        return () => container.removeEventListener('contextmenu', handleContextMenu);\r\n    }, [handleContextMenu, containerRef]);\r\n\r\n    const closeMenu = () => setMenuState(prev => ({ ...prev, visible: false }));\r\n\r\n    const openSettings = () => {\r\n        if (menuState.type === 'widget' && menuState.targetId && chartWidgetRef.current) {\r\n            const shape = chartWidgetRef.current.getShapeById(menuState.targetId);\r\n            if (shape) {\r\n                const primitive = shape.getPrimitive();\r\n                // Check if primitive supports getSettingsSchema\r\n                if (primitive && typeof (primitive as any).getSettingsSchema === 'function') {\r\n                    const schema = (primitive as any).getSettingsSchema();\r\n                    setSettingsState({\r\n                        isOpen: true,\r\n                        schema,\r\n                        targetShape: shape\r\n                    });\r\n                }\r\n            }\r\n        }\r\n        closeMenu();\r\n    };\r\n\r\n    const handleDelete = () => {\r\n        if (menuState.type === 'widget' && menuState.targetId && chartWidgetRef.current) {\r\n            chartWidgetRef.current.removeEntity(menuState.targetId);\r\n        }\r\n        closeMenu();\r\n    };\r\n\r\n    const handleRemoveAll = () => {\r\n        if (chartWidgetRef.current) {\r\n            chartWidgetRef.current.removeAllShapes();\r\n        }\r\n        closeMenu();\r\n    };\r\n\r\n    const closeSettings = () => setSettingsState(prev => ({ ...prev, isOpen: false }));\r\n\r\n    const saveSettings = (newSettings: any) => {\r\n        if (settingsState.targetShape) {\r\n            const primitive = settingsState.targetShape.getPrimitive();\r\n            if (primitive && typeof (primitive as any).applySettings === 'function') {\r\n                (primitive as any).applySettings(newSettings);\r\n            }\r\n        }\r\n    };\r\n\r\n    return {\r\n        menuState,\r\n        settingsState,\r\n        closeMenu,\r\n        openSettings,\r\n        handleDelete,\r\n        handleRemoveAll,\r\n        closeSettings,\r\n        saveSettings\r\n    };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAmBO,MAAM,iBAAiB,CAC1B,cACA;;IAEA,MAAM,CAAC,WAAW,aAAa,GAAG,IAAA,yKAAQ,EAAmB;QAAE,SAAS;QAAO,GAAG;QAAG,GAAG;QAAG,MAAM;IAAS;IAC1G,MAAM,CAAC,eAAe,iBAAiB,GAAG,IAAA,yKAAQ,EAAgB;QAAE,QAAQ;QAAO,QAAQ,EAAE;QAAE,aAAa;IAAK;IAEjH,MAAM,oBAAoB,IAAA,4KAAW;yDAAC,CAAC;YACnC,EAAE,cAAc;YAEhB,IAAI,CAAC,aAAa,OAAO,IAAI,CAAC,eAAe,OAAO,EAAE;YAEtD,4BAA4B;YAC5B,MAAM,OAAO,aAAa,OAAO,CAAC,qBAAqB;YACvD,MAAM,IAAI,EAAE,OAAO,GAAG,KAAK,IAAI;YAC/B,MAAM,IAAI,EAAE,OAAO,GAAG,KAAK,GAAG;YAE9B,cAAc;YACd,qEAAqE;YACrE,MAAM,WAAW,eAAe,OAAO,CAAC,OAAO,CAAC,GAAG;YAEnD,IAAI,UAAU;gBACV,6BAA6B;gBAC7B,aAAa;oBACT,SAAS;oBACT,GAAG,EAAE,OAAO;oBACZ,GAAG,EAAE,OAAO;oBACZ,MAAM;oBACN,UAAU,SAAS,EAAE;gBACzB;YACJ,OAAO;gBACH,kCAAkC;gBAClC,aAAa;oBACT,SAAS;oBACT,GAAG,EAAE,OAAO;oBACZ,GAAG,EAAE,OAAO;oBACZ,MAAM;gBACV;YACJ;QACJ;wDAAG;QAAC;QAAc;KAAe;IAEjC,kBAAkB;IAClB,IAAA,0KAAS;oCAAC;YACN,MAAM,YAAY,aAAa,OAAO;YACtC,IAAI,CAAC,WAAW;YAEhB,UAAU,gBAAgB,CAAC,eAAe;YAC1C;4CAAO,IAAM,UAAU,mBAAmB,CAAC,eAAe;;QAC9D;mCAAG;QAAC;QAAmB;KAAa;IAEpC,MAAM,YAAY,IAAM,aAAa,CAAA,OAAQ,CAAC;gBAAE,GAAG,IAAI;gBAAE,SAAS;YAAM,CAAC;IAEzE,MAAM,eAAe;QACjB,IAAI,UAAU,IAAI,KAAK,YAAY,UAAU,QAAQ,IAAI,eAAe,OAAO,EAAE;YAC7E,MAAM,QAAQ,eAAe,OAAO,CAAC,YAAY,CAAC,UAAU,QAAQ;YACpE,IAAI,OAAO;gBACP,MAAM,YAAY,MAAM,YAAY;gBACpC,gDAAgD;gBAChD,IAAI,aAAa,OAAO,AAAC,UAAkB,iBAAiB,KAAK,YAAY;oBACzE,MAAM,SAAS,AAAC,UAAkB,iBAAiB;oBACnD,iBAAiB;wBACb,QAAQ;wBACR;wBACA,aAAa;oBACjB;gBACJ;YACJ;QACJ;QACA;IACJ;IAEA,MAAM,eAAe;QACjB,IAAI,UAAU,IAAI,KAAK,YAAY,UAAU,QAAQ,IAAI,eAAe,OAAO,EAAE;YAC7E,eAAe,OAAO,CAAC,YAAY,CAAC,UAAU,QAAQ;QAC1D;QACA;IACJ;IAEA,MAAM,kBAAkB;QACpB,IAAI,eAAe,OAAO,EAAE;YACxB,eAAe,OAAO,CAAC,eAAe;QAC1C;QACA;IACJ;IAEA,MAAM,gBAAgB,IAAM,iBAAiB,CAAA,OAAQ,CAAC;gBAAE,GAAG,IAAI;gBAAE,QAAQ;YAAM,CAAC;IAEhF,MAAM,eAAe,CAAC;QAClB,IAAI,cAAc,WAAW,EAAE;YAC3B,MAAM,YAAY,cAAc,WAAW,CAAC,YAAY;YACxD,IAAI,aAAa,OAAO,AAAC,UAAkB,aAAa,KAAK,YAAY;gBACpE,UAAkB,aAAa,CAAC;YACrC;QACJ;IACJ;IAEA,OAAO;QACH;QACA;QACA;QACA;QACA;QACA;QACA;QACA;IACJ;AACJ;GA1Ga"}},
    {"offset": {"line": 1382, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/hooks/useTradeMonitor.ts"],"sourcesContent":["import { useState, useEffect, useMemo, useRef } from 'react';\r\nimport { fetchDirect } from '../lib/client-api';\r\n\r\nexport interface TradePosition {\r\n    ticket: number;\r\n    symbol: string;\r\n    type: number; // 0=Buy, 1=Sell\r\n    vol: number;\r\n    open: number;\r\n    current: number;\r\n    sl: number;\r\n    tp: number;\r\n    profit: number;\r\n    realizedPl?: number; // Added for separate tracking\r\n    swap: number;\r\n    commission: number;\r\n    comment: string;\r\n    magic?: number; // Added for Magic Number Tracking\r\n    botId: string;\r\n    brokerId?: string; // Derived\r\n    time?: number; // Broker Open Time\r\n    status?: string;\r\n    customStatus?: string; // Added for robustness\r\n    metrics?: {\r\n        realizedPl?: number;\r\n        historyCommission?: number;\r\n        historySwap?: number;\r\n    };\r\n    runningRr?: number; // Added for Run R Calculation\r\n    // History / UI Compatibility\r\n    id?: string;\r\n    entryPrice?: number;\r\n    currentPrice?: number;\r\n}\r\n\r\nexport interface AggregatedTrade {\r\n    tradeId: string;\r\n    symbol: string;\r\n    strategy: string;\r\n    direction: 'BUY' | 'SELL';\r\n    totalVol: number;\r\n    volume: number; // Added for compatibility\r\n    size?: number; // Added for compatibility with ChartContainer\r\n    totalProfit: number;\r\n    totalCommission: number;\r\n    totalSwap: number;\r\n    status: 'RUNNING' | 'PARTIAL' | 'CLOSED' | 'OFFLINE';\r\n    positions: TradePosition[];\r\n    // Computed for Group\r\n    avgEntry: number;\r\n    avgSl: number;\r\n    avgTp: number;\r\n    currentRr: number;\r\n    realizedPl: number;\r\n    unrealizedPl: number;\r\n    openTime: number;\r\n    avgPrice: number;\r\n    runningRr: number;\r\n    entryLabel?: string;\r\n    slLabel?: string;\r\n    tpLabel?: string;\r\n    // History Fields\r\n    closeTime?: number;\r\n    exitPrice?: number;\r\n    commission?: number;\r\n    swap?: number;\r\n}\r\n\r\nimport { socketService } from '../services/socket';\r\nimport { useWorkspaceStore } from '../stores/useWorkspaceStore'; // Import Store\r\n\r\nexport const useTradeMonitor = () => {\r\n    const isTestMode = useWorkspaceStore(state => state.isTestMode); // React to Global Switch\r\n\r\n    const [positions, setPositions] = useState<TradePosition[]>([]);\r\n    const [aggregatedTradesState, setAggregatedTradesState] = useState<AggregatedTrade[]>([]);\r\n\r\n    // State Refs for merging (to avoid dependency loops)\r\n    const masterTradesRef = useRef<any[]>([]);\r\n    const livePositionsRef = useRef<TradePosition[]>([]);\r\n\r\n    // 1. Slow Poll: Master Trades (Source of Truth for Metadata) - 1s\r\n    const fetchMasterTrades = async () => {\r\n        try {\r\n            const envParam = isTestMode ? 'test' : 'live';\r\n            const tradesRes = await fetchDirect(`/api/active-trades?env=${envParam}`);\r\n            const tradesData = await tradesRes.json();\r\n            const masterTrades = tradesData.success ? tradesData.trades : [];\r\n            masterTradesRef.current = masterTrades;\r\n        } catch (e) {\r\n            console.error(\"Master Trade Poll Error\", e);\r\n        }\r\n    };\r\n\r\n    // 2. Fast Poll: Live Positions (Profit/Loss updates) - 50ms\r\n    const fetchLivePositions = async () => {\r\n        try {\r\n            const posRes = await fetchDirect('/api/positions');\r\n            const posData = await posRes.json();\r\n            const livePositions: TradePosition[] = posData.success ? posData.positions : [];\r\n\r\n            livePositionsRef.current = livePositions;\r\n            setPositions(livePositions);\r\n\r\n            // 3. Merge Logic (Master + Live) -> Aggregated\r\n            // PERFORMED IN-PLACE to ensure 50ms reactivity\r\n            const combined: AggregatedTrade[] = [];\r\n            const claimedTickets = new Set<string>();\r\n\r\n            const masterTrades = masterTradesRef.current; // Use latest Ref\r\n\r\n            // Process Master Trades first\r\n            masterTrades.forEach((mt: any) => {\r\n                const tId = mt.id.toString();\r\n                // Magic might be in params (if ID is string) or implicit (if ID is numeric)\r\n                const tMagic = (mt.params && mt.params.magic) ? mt.params.magic.toString() : null;\r\n\r\n                // Find matching positions (by Magic Number OR Comment)\r\n                const matches = livePositions.filter(p => {\r\n                    // STRICT ID MATCH ONLY (User Mandate)\r\n                    // MQL5 sends position.id which corresponds to the Trade ID\r\n                    return (p as any).id && (p as any).id.toString() === tId;\r\n                });\r\n\r\n                matches.forEach(m => claimedTickets.add(`${m.botId}-${m.ticket}`));\r\n\r\n                // 4. DB-First Merging Logic (Task-0189 Refactor)\r\n                if (mt.executions && Array.isArray(mt.executions)) {\r\n                    const dbExecutions = mt.executions;\r\n                    const mergedPositions: TradePosition[] = [];\r\n                    const usedLiveIds = new Set<string>();\r\n\r\n                    dbExecutions.forEach((exec: any) => {\r\n                        // ROBUSTNESS: Handle both DB (snake_case) and API (camelCase) keys\r\n                        const execBotId = (exec.bot_id || exec.botId || \"\").trim();\r\n\r\n                        // FIX: Search GLOBAL livePositions, not the pre-filtered 'matches'.\r\n                        // 'matches' only contains positions where pos.id == master.id.\r\n                        // But here we want to link via BotID + Ticket/Magic even if ID mismatch.\r\n                        // FIX: Use robust execBotId key\r\n                        // CRITICAL: User Mandate \"IMMER DIE TRADE ID nehmen\"\r\n                        // Live Position 'id' corresponds to the Master Trade ID (stored as magic_number in DB)\r\n                        const liveMatch = livePositions.find(m =>\r\n                            m.botId === execBotId &&\r\n                            exec.magic_number && m.id == exec.magic_number\r\n                        );\r\n\r\n                        if (liveMatch) {\r\n                            usedLiveIds.add(liveMatch.botId);\r\n                            // Parse Broker Name from BotID (e.g. \"FTMO_12345\" -> \"FTMO\")\r\n                            const parsedBroker = (execBotId.includes('_'))\r\n                                ? execBotId.split('_')[0]\r\n                                : execBotId;\r\n\r\n\r\n                            // FIX: Sum History + Current for LIVE matches too\r\n                            const liveComm = (liveMatch.commission || 0) + ((liveMatch as any).metrics?.historyCommission || 0);\r\n                            const liveSwap = (liveMatch.swap || 0) + ((liveMatch as any).metrics?.historySwap || 0);\r\n\r\n\r\n                            // FIX: Data Persistence - If Live is 0/Missing (e.g. Closed), prefer DB Snapshots\r\n                            // Strictly use Broker Execution Data (Source of Truth). Do NOT fallback to Master (Aggregate).\r\n                            const openPrice = liveMatch.open || exec.entry_price || 0;\r\n                            const slPrice = liveMatch.sl || exec.sl || 0;\r\n                            const tpPrice = liveMatch.tp || exec.tp || 0;\r\n\r\n                            // Fix Open Time Overwrite (MQL5 sends CloseTime in 'time' field when closed)\r\n                            // Usage: TradesPanel expects SECONDS for child rows. DB stores MILLISECONDS.\r\n                            const openTimeSeconds = (exec.open_time && exec.open_time > 0)\r\n                                ? (exec.open_time / 1000)\r\n                                : liveMatch.time;\r\n\r\n                            mergedPositions.push({\r\n                                ...liveMatch,\r\n                                commission: liveComm,\r\n                                swap: liveSwap,\r\n                                open: openPrice,\r\n                                sl: slPrice,\r\n                                tp: tpPrice,\r\n                                time: openTimeSeconds,\r\n                                // PREFER: Server Injected Name > Parsed Name > Live > GUID\r\n                                brokerId: exec.brokerName || parsedBroker || liveMatch.brokerId || exec.broker_id,\r\n                                status: 'RUNNING',\r\n                                realizedPl: (liveMatch as any).metrics?.realizedPl || exec.realized_pl || 0, // FIX: Map from Metrics or DB\r\n                                comment: liveMatch.comment || `[${exec.status}]`,\r\n                                runningRr: (() => {\r\n                                    // Calculate Run R for Live Match\r\n                                    const open = liveMatch.open || exec.entry_price || 0;\r\n                                    const sl = liveMatch.sl || exec.sl || 0;\r\n                                    // Live Match has 'current' price from broker\r\n                                    const current = liveMatch.current || open;\r\n                                    const distSl = Math.abs(open - sl);\r\n\r\n                                    if (distSl === 0) return 0;\r\n                                    const type = liveMatch.type; // 0=Buy, 1=Sell\r\n\r\n                                    // Ensure type check handles string/number mismatch\r\n                                    const isBuy = (type === 0 || (type as any) === '0' || (type as any) === 'BUY');\r\n\r\n                                    const distRun = isBuy\r\n                                        ? (current - open)\r\n                                        : (open - current);\r\n                                    return distRun / distSl;\r\n                                })()\r\n                            });\r\n                        } else {\r\n                            // Fallback numeric ID for UI keys if ticket missing\r\n                            const fallbackTicket = -1 * (parseInt((exec.id || '0').replace(/\\D/g, '')) || Math.floor(Math.random() * 100000));\r\n\r\n                            // Parse Broker Name\r\n                            const parsedBroker = (execBotId.includes('_'))\r\n                                ? execBotId.split('_')[0]\r\n                                : execBotId;\r\n\r\n                            mergedPositions.push({\r\n                                botId: execBotId,\r\n                                symbol: mt.symbol,\r\n                                type: mt.direction,\r\n                                vol: exec.volume || 0,\r\n                                realizedPl: exec.realized_pl || 0, // NEW: Map DB Realized PnL\r\n                                // profit: exec.realized_pl || 0, // REMOVED: Duplicate key. Profit usually means Floating.\r\n                                // FIX: Sum History + Current because MQL5 sends them separate\r\n                                commission: (exec.commission || 0) + (exec.metrics?.historyCommission || 0),\r\n                                swap: (exec.swap || 0) + (exec.metrics?.historySwap || 0),\r\n                                current: exec.exit_price || 0,\r\n                                open: exec.entry_price || 0,\r\n                                sl: exec.sl || 0,\r\n                                tp: exec.tp || 0,\r\n                                profit: exec.unrealized_pl || 0, // Fallback to DB Unrealized for 'profit' field\r\n                                ticket: exec.ticket || fallbackTicket,\r\n                                // Fix: Use Server Injected Name > Parsed Name > GUID\r\n                                brokerId: exec.brokerName || parsedBroker || exec.broker_id || 'PENDING',\r\n                                comment: `[${exec.status}]`,\r\n                                status: exec.status,\r\n                                // FIX: Convert MS to Seconds for UI consistency\r\n                                time: (exec.open_time && exec.open_time > 0) ? (exec.open_time / 1000) : 0,\r\n                                runningRr: (() => {\r\n                                    // Calculate Run R for DB Fallback\r\n                                    const open = exec.entry_price || 0;\r\n                                    const sl = exec.sl || 0;\r\n                                    // Use exit_price for closed, or fall back to open if 0\r\n                                    const current = exec.exit_price || open;\r\n                                    const distSl = Math.abs(open - sl);\r\n\r\n                                    if (distSl === 0) return 0;\r\n                                    const type = mt.direction; // 1=Buy(Need Check), 0=Sell? MT5 is 0=Buy, 1=Sell. \r\n                                    // Wait, mt.direction is 1 or 0? \r\n                                    // DB: direction INTEGER. Usually 0=Buy, 1=Sell in our schema? \r\n                                    // Let's check mt.direction usage above: \"mt.direction === 1 ? 'BUY' : 'SELL'\" (Line 318)\r\n                                    // So 1 is BUY. \r\n\r\n                                    const distRun = (mt.direction === 1)\r\n                                        ? (current - open)\r\n                                        : (open - current);\r\n                                    return distRun / distSl;\r\n                                })()\r\n                            });\r\n                        }\r\n                    });\r\n\r\n                    // Add Live Orphans (Safety)\r\n                    matches.forEach(m => {\r\n                        if (!usedLiveIds.has(m.botId)) mergedPositions.push(m);\r\n                    });\r\n\r\n                    matches.length = 0;\r\n                    matches.push(...mergedPositions);\r\n                }\r\n\r\n                // Calculate Aggregates\r\n                let totalVol = 0;\r\n                let unrealizedPl = 0; // From Live Positions\r\n                let totalComm = 0;\r\n                let totalSwap = 0;\r\n                let avgEntry = 0; // Simple Weighted\r\n                let avgPrice = 0; // Current Market Price\r\n\r\n                let aggregatedRealized = 0; // Sum of Broker Realized PnL\r\n\r\n                if (matches.length > 0) {\r\n                    matches.forEach(p => {\r\n                        totalVol += Number(p.vol || 0);\r\n\r\n                        // Robustness: If match reports CLOSED, its open profit is 0 by definition.\r\n                        const matchProfit = (p.customStatus === 'CLOSED') ? 0 : Number(p.profit || 0);\r\n                        unrealizedPl += matchProfit;\r\n\r\n                        // AGGREGATE REALIZED PNL from Matches (Broker Executions)\r\n                        // Priority: Metrics (Live) > Direct Property (DB Fallback)\r\n                        if (p.metrics && p.metrics.realizedPl !== undefined) {\r\n                            aggregatedRealized += Number(p.metrics.realizedPl || 0);\r\n                        } else if (p.realizedPl !== undefined) {\r\n                            aggregatedRealized += Number(p.realizedPl || 0);\r\n                        }\r\n\r\n                        totalComm += Number(p.commission || 0);\r\n                        totalSwap += Number(p.swap || 0);\r\n                        avgEntry += (Number(p.open || 0) * Number(p.vol || 0));\r\n                        avgPrice += (Number(p.current || 0) * Number(p.vol || 0));\r\n                    });\r\n                    avgEntry = totalVol > 0 ? avgEntry / totalVol : 0;\r\n                    avgPrice = totalVol > 0 ? avgPrice / totalVol : 0;\r\n                } else {\r\n                    // Use Master values if no execution yet\r\n                    totalVol = mt.volume || 0;\r\n                    avgEntry = mt.entry_price || 0;\r\n                    avgPrice = mt.entry_price || 0; // Fallback to entry\r\n                }\r\n\r\n                // ... RR Calculations ...\r\n                const masterEntry = mt.entry_price || 0;\r\n                const masterSl = mt.sl || 0;\r\n                const masterTp = mt.tp || 0;\r\n\r\n                const distSl = Math.abs(masterEntry - masterSl);\r\n                const distTp = Math.abs(masterTp - masterEntry);\r\n\r\n                // Plan R: Based on Initial Master Trade paramters (Fixed)\r\n                let plannedRr = 0;\r\n                if (distSl > 0) plannedRr = distTp / distSl;\r\n\r\n                // Run R: Based on Average Entry vs Current Price (Dynamic)\r\n                let runningRr = 0;\r\n                // Use AvgEntry (Weighted) for Running R to reflect actual position\r\n                if (distSl > 0 && avgPrice > 0) {\r\n                    const distRun = mt.direction === 1\r\n                        ? (avgPrice - avgEntry)\r\n                        : (avgEntry - avgPrice);\r\n                    runningRr = distRun / distSl;\r\n                }\r\n\r\n                // DB Realized PnL (mt.realized_pl) vs Aggregated\r\n                // FIX: Check 'mt.realizedPl' (CamelCase from Backend) AND 'mt.realized_pl' (SnakeCase Legacy)\r\n                const masterRealized = (mt.realizedPl !== undefined) ? mt.realizedPl : (mt.realized_pl || 0);\r\n                const realizedPl = (matches.length > 0) ? aggregatedRealized : masterRealized;\r\n\r\n                // FORCE CLOSED STATE LOGIC\r\n                // If DB says CLOSED, we must zero out Unrealized, even if we had ghost matches\r\n                // (Though strict matching should prevent ghost matches on closed trades)\r\n                const isClosed = mt.status === 'CLOSED';\r\n                if (isClosed) {\r\n                    unrealizedPl = 0;\r\n                }\r\n\r\n                // Params Extraction (Anchors/Labels)\r\n                let params: any = mt.params;\r\n                if (typeof params === 'string') {\r\n                    try { params = JSON.parse(params); } catch { params = {}; }\r\n                }\r\n                if (!params || typeof params !== 'object') params = {};\r\n\r\n                const formatAnchor = (a: any) => {\r\n                    if (!a) return undefined;\r\n                    let timeStr = '';\r\n                    if (a.time) {\r\n                        // Heuristic: seconds vs ms\r\n                        const ms = (typeof a.time === 'number' && a.time < 10000000000) ? a.time * 1000 : a.time;\r\n                        timeStr = new Date(ms).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });\r\n                    }\r\n                    const tf = a.timeframe || a.tf;\r\n                    return tf ? `[${tf}] ${timeStr}` : (timeStr || a.name || 'Anchor');\r\n                };\r\n\r\n                let entryLabel = formatAnchor(params.entry?.anchor);\r\n                if (!entryLabel && mt.entry_price === 0) {\r\n                    entryLabel = 'Market';\r\n                }\r\n\r\n                let slLabel = formatAnchor(params.sl?.anchor);\r\n                if (!slLabel && mt.sl === 0) {\r\n                    slLabel = 'Auto';\r\n                }\r\n\r\n                let tpLabel = formatAnchor(params.tp?.anchor);\r\n                // Auto TP logic: explicit 0 or params flag\r\n                if (!tpLabel) {\r\n                    if (mt.tp === 0 || (params.tp && (params.tp.method === 'RR' || params.tp.auto))) {\r\n                        tpLabel = 'Auto';\r\n                    }\r\n                }\r\n\r\n                combined.push({\r\n                    tradeId: tId,\r\n                    symbol: mt.symbol,\r\n                    strategy: mt.strategy || 'Manual',\r\n                    direction: mt.direction === 1 ? 'BUY' : 'SELL',\r\n                    totalVol: totalVol,\r\n                    volume: totalVol, // Map totalVol to volume\r\n                    realizedPl: realizedPl,\r\n                    unrealizedPl: unrealizedPl,\r\n                    totalProfit: realizedPl + unrealizedPl,\r\n                    totalCommission: totalComm,\r\n                    totalSwap: totalSwap,\r\n                    status: isClosed ? 'CLOSED' : (matches.length > 0 ? 'RUNNING' : (mt.status || 'PENDING')),\r\n                    positions: matches,\r\n                    avgEntry: avgEntry,\r\n                    avgSl: masterSl, // Show Master SL\r\n                    avgTp: masterTp, // Show Master TP\r\n                    currentRr: plannedRr,\r\n                    runningRr: runningRr,\r\n                    avgPrice: avgPrice,\r\n                    openTime: mt.created_at || Date.now(),\r\n                    entryLabel: entryLabel,\r\n                    slLabel: slLabel,\r\n                    tpLabel: tpLabel\r\n                });\r\n            });\r\n\r\n            // Process Orphans\r\n            const orphanGroups: Record<string, AggregatedTrade> = {};\r\n\r\n            livePositions.forEach(pos => {\r\n                const key = `${pos.botId}-${pos.ticket}`;\r\n                if (claimedTickets.has(key)) return;\r\n\r\n                // FIX: Strict Protocol Compliance. ID comes from 'id' field (mapped from Magic in Adapter).\r\n                // \"Magic Number\" is internal to MT5. External consumers use 'id'.\r\n                // Comment is NOT a source of ID.\r\n                let oId = (pos as any).id ? (pos as any).id.toString() : null;\r\n\r\n                if (!oId || oId === '0') {\r\n                    // Fallback ONLY to ticket if no ID provided (Unmanaged/Legacy)\r\n                    oId = `ticket-${pos.ticket}`;\r\n                }\r\n\r\n                // Final Safety Cast (TS Lint Fix)\r\n                const finalId: string = oId || `ticket-${pos.ticket}`;\r\n\r\n                if (!orphanGroups[finalId]) {\r\n                    orphanGroups[finalId] = {\r\n                        tradeId: finalId,\r\n                        symbol: pos.symbol,\r\n                        strategy: pos.comment?.split('|')[0] || 'Manual',\r\n                        direction: pos.type === 0 ? 'BUY' : 'SELL',\r\n                        totalVol: 0,\r\n                        volume: 0,\r\n                        realizedPl: 0,\r\n                        unrealizedPl: 0,\r\n                        totalProfit: 0, totalCommission: 0, totalSwap: 0,\r\n                        status: 'RUNNING', positions: [],\r\n                        avgEntry: 0, avgSl: 0, avgTp: 0, avgPrice: 0,\r\n                        currentRr: 0, runningRr: 0,\r\n                        openTime: Date.now()\r\n                    };\r\n                    combined.push(orphanGroups[oId]);\r\n                }\r\n\r\n                const g = orphanGroups[oId];\r\n                g.positions.push(pos);\r\n                g.totalVol += pos.vol;\r\n                g.unrealizedPl += pos.profit;\r\n                g.totalProfit += pos.profit;\r\n                g.totalCommission += pos.commission;\r\n                g.totalSwap += pos.swap;\r\n                g.avgEntry += (pos.open * pos.vol); // Sum for weighting\r\n                g.avgPrice += (pos.current * pos.vol);\r\n                g.avgSl += (pos.sl * pos.vol);\r\n                g.avgTp += (pos.tp * pos.vol);\r\n            });\r\n\r\n            Object.values(orphanGroups).forEach(g => {\r\n                if (g.totalVol > 0) {\r\n                    g.avgEntry /= g.totalVol;\r\n                    g.avgPrice /= g.totalVol;\r\n                    g.avgSl /= g.totalVol;\r\n                    g.avgTp /= g.totalVol;\r\n\r\n                    // Calc RR for Orphans\r\n                    const distSl = Math.abs(g.avgEntry - g.avgSl);\r\n                    if (distSl > 0) {\r\n                        g.currentRr = Math.abs(g.avgTp - g.avgEntry) / distSl;\r\n                        const distRun = g.direction === 'BUY'\r\n                            ? (g.avgPrice - g.avgEntry)\r\n                            : (g.avgEntry - g.avgPrice);\r\n                        g.runningRr = distRun / distSl;\r\n                    }\r\n                }\r\n            });\r\n\r\n            setAggregatedTradesState(combined);\r\n\r\n        } catch (e) {\r\n            console.error(\"Monitor Poll Error\", e);\r\n        }\r\n    };\r\n\r\n    useEffect(() => {\r\n        // Reset State on Env Change\r\n        setPositions([]);\r\n        setAggregatedTradesState([]);\r\n        masterTradesRef.current = [];\r\n        livePositionsRef.current = [];\r\n\r\n        // Initial Loads\r\n        fetchMasterTrades().then(() => fetchLivePositions());\r\n\r\n        // ULTRA-LOW LATENCY: 50ms Fallback + Socket Push\r\n        const intervalFast = setInterval(fetchLivePositions, 50);\r\n        const intervalSlow = setInterval(fetchMasterTrades, 1000);\r\n\r\n        // Push Protocol Listener\r\n        const socket = socketService.getSocket();\r\n\r\n        const onSignal = () => {\r\n            // Instant Trigger for BOTH Live and Master Data\r\n            fetchLivePositions();\r\n            fetchMasterTrades();\r\n        };\r\n\r\n        socket.on('trades_update_signal', onSignal);\r\n\r\n        return () => {\r\n            clearInterval(intervalFast);\r\n            clearInterval(intervalSlow);\r\n            socket.off('trades_update_signal', onSignal);\r\n        };\r\n    }, [isTestMode]); // Re-run when Environment Switches\r\n\r\n    const modifyTrade = async (modification: { action: string, tradeId: string, percent?: number }): Promise<boolean> => {\r\n        // Find relevant accounts for this tradeID\r\n        const targetTrade = aggregatedTradesState.find(t => t.tradeId === modification.tradeId);\r\n        if (!targetTrade) {\r\n            console.error(\"Trade not found for modification:\", modification.tradeId);\r\n            return false;\r\n        }\r\n\r\n        // De-duplicate BotIDs\r\n        const accounts = targetTrade.positions.map(p => ({ botId: p.botId }));\r\n\r\n        // USER QUERY 7200: \"HÃ–R MIT DIESER MAGIC NUMBER AUF! WIR BENUTZEEN DIE TRADE ID\"\r\n        // Implicitly, the `modification.tradeId` (MasterID) IS the Trade ID.\r\n        // We do NOT attempt to find a mismatched \"MQL ID\" or \"Magic\". We send the Master ID.\r\n        // If MQL5 uses a different ID, that logic must be fixed in MQL5 or Mapping, not here.\r\n\r\n        console.log(`[modifyTrade] Action: ${modification.action} TradeID: ${modification.tradeId}`);\r\n        console.log(`[modifyTrade] ðŸš€ Sending POST to /api/trade/modify...`);\r\n\r\n        try {\r\n            const res = await fetchDirect('/api/trade/modify', {\r\n                method: 'POST',\r\n                headers: { 'Content-Type': 'application/json' },\r\n                body: JSON.stringify({\r\n                    modification,\r\n                    accounts\r\n                })\r\n            });\r\n            console.log(`[modifyTrade] Response Status: ${res.status}`);\r\n            const body = await res.json();\r\n            console.log(`[modifyTrade] Response Body: `, body);\r\n            return body.success === true;\r\n        } catch (e) {\r\n            console.error(\"[modifyTrade] âŒ Modification Network Error:\", e);\r\n            return false;\r\n        }\r\n    };\r\n\r\n    return { params: {}, aggregatedTrades: aggregatedTradesState, positions, modifyTrade };\r\n};\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 1842, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/hooks/useChartData.ts"],"sourcesContent":["import { useState, useEffect, useRef } from 'react';\r\nimport { MT5Datafeed } from '../services/MT5Datafeed';\r\nimport { generatePhantomBars, getTimeframeSeconds } from '../utils/chartUtils';\r\nimport { fetchMessages } from '../services/api';\r\n\r\nexport interface ChartDataHookOptions {\r\n    symbol: string;\r\n    timeframe: string;\r\n    botId: string;\r\n    isActivePane: boolean; // For smart streaming\r\n    onTick?: (candle: any) => void;\r\n}\r\n\r\nexport function useChartData({ symbol, timeframe, botId, isActivePane, onTick }: ChartDataHookOptions) {\r\n    const [data, setData] = useState<any[]>([]);\r\n    const [horizonData, setHorizonData] = useState<any[]>([]);\r\n    const [isLoading, setIsLoading] = useState(false);\r\n    const [isSyncing, setIsSyncing] = useState(false); // For backlog filling\r\n\r\n    const [isChartReady, setIsChartReady] = useState(false);\r\n    const [syncError, setSyncError] = useState<string | undefined>(undefined);\r\n    const [syncStatus, setSyncStatus] = useState<string>('SYNCING');\r\n\r\n    // Refs\r\n    const lastCandleRef = useRef<any>(null);\r\n    const datafeedRef = useRef<MT5Datafeed | null>(null);\r\n    const symbolRef = useRef(symbol);\r\n    const tfRef = useRef(timeframe);\r\n    const isLoadingRef = useRef(false);\r\n\r\n    // Sync Refs & Clear Data for Instant Feedback\r\n    useEffect(() => {\r\n        symbolRef.current = symbol;\r\n        tfRef.current = timeframe;\r\n        // INSTANT CLEAR: Immediately clear data so the UI reflects the switch\r\n        setData([]);\r\n        setHorizonData([]); // Clear phantom bars\r\n        // RESET LOADING: Allow new fetch to proceed even if previous one was running\r\n        setIsLoading(false);\r\n        isLoadingRef.current = false;\r\n\r\n        // RESET LAST CANDLE: Prevent ghost candles from previous timeframe/symbol\r\n        lastCandleRef.current = null;\r\n\r\n        // RESET LOCK STATE\r\n        setIsChartReady(false);\r\n        setSyncError(undefined);\r\n    }, [symbol, timeframe]);\r\n\r\n    // Initialize Datafeed Adapter\r\n    useEffect(() => {\r\n        if (!datafeedRef.current) {\r\n            datafeedRef.current = new MT5Datafeed();\r\n        }\r\n    }, []);\r\n\r\n    // Helper: Fetch History (Progressive / Chunked)\r\n    const fetchHistory = async (isMerge: boolean = false) => {\r\n        if (!symbol || !botId) return;\r\n\r\n        // Prevent concurrent fetches or double-execution\r\n        if (isLoadingRef.current) return;\r\n\r\n        try {\r\n            if (!isMerge) {\r\n                setIsLoading(true);\r\n                isLoadingRef.current = true;\r\n            }\r\n\r\n            const targetTotal = 10000; // Goal: 10k bars\r\n            const chunkSize = 500;     // Packet size: 500 (safe balance)\r\n\r\n            // 1. Initial Fetch (Latest)\r\n            console.log(`[useChartData] ðŸš€ Starting Progressive Fetch for ${symbol} ${timeframe}`);\r\n            let url = `http://127.0.0.1:3005/history?symbol=${symbol}&timeframe=${timeframe}&limit=${chunkSize}&_=${Date.now()}`;\r\n\r\n            let res = await fetch(url);\r\n            let response = await res.json();\r\n\r\n            if (!response.success || !response.candles) {\r\n                console.warn(\"[useChartData] Initial fetch failed or empty.\");\r\n                setIsLoading(false);\r\n                isLoadingRef.current = false;\r\n                return;\r\n            }\r\n\r\n            let gatheredBars = response.candles.map((c: any) => {\r\n                let t = Number(c.time);\r\n                if (t > 100000000000) t = t / 1000;\r\n                return {\r\n                    time: t,\r\n                    open: c.open, high: c.high, low: c.low, close: c.close, volume: c.volume || 0\r\n                };\r\n            }).sort((a: any, b: any) => a.time - b.time);\r\n\r\n            // Set Initial Data or Merge\r\n            if (gatheredBars.length > 0) {\r\n                // STALENESS CHECK\r\n                if (symbolRef.current !== symbol || tfRef.current !== timeframe) {\r\n                    console.log(`[useChartData] âš ï¸ Initial fetch discarded for ${symbol} ${timeframe}`);\r\n                    return;\r\n                }\r\n\r\n                // MERGE LIVE CANDLE (Fix for Initial Fetch Flicker)\r\n                const liveCandle = lastCandleRef.current;\r\n                if (liveCandle) {\r\n                    const lastFetched = gatheredBars[gatheredBars.length - 1];\r\n                    if (!lastFetched || lastFetched.time < liveCandle.time) {\r\n                        gatheredBars.push(liveCandle);\r\n                    } else if (lastFetched.time === liveCandle.time) {\r\n                        gatheredBars[gatheredBars.length - 1] = liveCandle;\r\n                    }\r\n                }\r\n\r\n                if (isMerge) {\r\n                    // SMART MERGE: Integrate new chunk into existing data\r\n                    // Filter out bars that are already in 'data' (deduplication)\r\n                    // But beware: 'data' state might be stale in closure?\r\n                    // We can use functional update or assume 'data' is reasonably fresh if no rapid updates.\r\n                    // Better: We just update 'data' by slicing.\r\n\r\n                    console.log(`[useChartData] ðŸ§¬ Smart Merge: Integrating ${gatheredBars.length} bars...`);\r\n\r\n                    setData(prevData => {\r\n                        // Create a map of existing bars for overlap check? No, just time-based merge.\r\n                        // Simple: Filter prevData to keep only bars OLDER than the new chunk's first bar.\r\n                        // Then append new chunk.\r\n                        if (prevData.length === 0) return [...gatheredBars];\r\n\r\n                        const firstNewTime = gatheredBars[0].time;\r\n                        const nonOverlappingOld = prevData.filter(d => d.time < firstNewTime);\r\n                        return [...nonOverlappingOld, ...gatheredBars];\r\n                    });\r\n\r\n                    // Update Horizon\r\n                    const latest = gatheredBars[gatheredBars.length - 1];\r\n                    lastCandleRef.current = { ...latest };\r\n                    setHorizonData(generatePhantomBars(latest.time, latest.close, timeframe));\r\n\r\n                    // Stop loop if merging\r\n                    setIsLoading(false);\r\n                    isLoadingRef.current = false;\r\n                    return;\r\n                } else {\r\n                    // FRESH LOAD\r\n                    setData([...gatheredBars]);\r\n                    lastCandleRef.current = { ...gatheredBars[gatheredBars.length - 1] };\r\n                    if (gatheredBars.length > 0) {\r\n                        setHorizonData(generatePhantomBars(gatheredBars[gatheredBars.length - 1].time, gatheredBars[gatheredBars.length - 1].close, timeframe));\r\n\r\n                        // FIX: PROGRESSIVE LOADING\r\n                        // Show chart immediately after first chunk, while backfilling continues in background\r\n                        setIsLoading(false);\r\n                    }\r\n                }\r\n            }\r\n\r\n            // 2. Background Loop (Load older data)\r\n            while (gatheredBars.length < targetTotal) {\r\n                if (gatheredBars.length === 0) break;\r\n\r\n                const oldestTime = gatheredBars[0].time; // First element is oldest\r\n\r\n                // Fetch older than current oldest\r\n                // Fix: Convert 'oldestTime' (seconds) back to MS for the backend if needed.\r\n                // Since we detected MS in the response earlier, we know backend sends MS.\r\n                // But let's be robust: If the ORIGINAL response was MS, we should query in MS.\r\n                // Simplest: Assume backend stores MS (standard).\r\n                const toMs = Math.floor(oldestTime * 1000);\r\n                url = `http://127.0.0.1:3005/history?symbol=${symbol}&timeframe=${timeframe}&limit=${chunkSize}&to=${toMs}&_=${Date.now()}`;\r\n                // console.log(`[useChartData] ðŸ“¡ Fetching chunk older than ${new Date(toMs).toISOString()} (to=${toMs})`);\r\n\r\n                res = await fetch(url);\r\n                response = await res.json();\r\n\r\n                if (!response.success || !response.candles || response.candles.length === 0) {\r\n                    console.log(\"[useChartData] âœ… End of history reached.\");\r\n                    break;\r\n                }\r\n\r\n                const newChunk = response.candles.map((c: any) => {\r\n                    let t = Number(c.time);\r\n                    if (t > 100000000000) t = t / 1000;\r\n                    return {\r\n                        time: t,\r\n                        open: c.open, high: c.high, low: c.low, close: c.close, volume: c.volume || 0\r\n                    };\r\n                }).sort((a: any, b: any) => a.time - b.time);\r\n\r\n                // Dedup\r\n                const uniqueNew = newChunk.filter((nc: any) => nc.time < oldestTime);\r\n\r\n                if (uniqueNew.length === 0) {\r\n                    console.log(\"[useChartData] No unique older bars found. Stopping.\");\r\n                    break;\r\n                }\r\n\r\n                gatheredBars = [...uniqueNew, ...gatheredBars];\r\n\r\n                // STALENESS CHECK: Ensure we are still on the same symbol/tf\r\n                if (symbolRef.current !== symbol || tfRef.current !== timeframe) {\r\n                    console.log(`[useChartData] âš ï¸ Fetch aborted for ${symbol} ${timeframe} (switched to ${symbolRef.current} ${tfRef.current})`);\r\n                    return; // Stop this loop and function\r\n                }\r\n\r\n                // Update UI incrementally\r\n                // Update UI incrementally but PRESERVE Live Candle State\r\n                const liveCandle = lastCandleRef.current;\r\n                let finalData = [...gatheredBars];\r\n\r\n                if (liveCandle) {\r\n                    const lastFetched = finalData[finalData.length - 1];\r\n                    if (!lastFetched || lastFetched.time < liveCandle.time) {\r\n                        // Append Live Candle if missing from fetch\r\n                        finalData.push(liveCandle);\r\n                    } else if (lastFetched.time === liveCandle.time) {\r\n                        // CRITICAL FIX: Overwrite stale DB candle with LIVE candle\r\n                        // The Live Stream is always more up-to-date than the DB during active trading.\r\n                        finalData[finalData.length - 1] = liveCandle;\r\n                    }\r\n                }\r\n\r\n                setData(finalData);\r\n\r\n                // Small delay to prevent network congestion\r\n                await new Promise(r => setTimeout(r, 100));\r\n            }\r\n\r\n            setIsLoading(false);\r\n            isLoadingRef.current = false;\r\n        } catch (e) {\r\n            console.error(`[useChartData] Error fetching history for ${symbol}:`, e);\r\n            setIsLoading(false);\r\n            isLoadingRef.current = false;\r\n        }\r\n    };\r\n\r\n    // Main Streaming Effect\r\n    useEffect(() => {\r\n        if (!symbol || !botId) {\r\n            return;\r\n        }\r\n\r\n        const onSyncComplete = (payload: any) => {\r\n            if (payload.symbol === symbol && payload.timeframe === timeframe) {\r\n                console.log(`[useChartData] ðŸ”“ SYNC COMPLETE for ${symbol} ${timeframe}. Unlocking UI.`);\r\n                setIsChartReady(true);\r\n                // Trigger History Fetch ONLY if we don't have data yet\r\n                if (!lastCandleRef.current) {\r\n                    fetchHistory(false);\r\n                } else {\r\n                    console.log(`[useChartData] â© SYNC COMPLETE. Triggering Smart Merge to fill gaps.`);\r\n                    fetchHistory(true); // isMerge = true\r\n                }\r\n            }\r\n        };\r\n\r\n        const onSyncError = (payload: any) => {\r\n            if (payload.symbol === symbol && payload.timeframe === timeframe) {\r\n                console.error(`[useChartData] âŒ SYNC ERROR for ${symbol} ${timeframe}: ${payload.error}`);\r\n                setSyncError(payload.error || \"Sync Failed\");\r\n            }\r\n        };\r\n\r\n        // 0. Listen for SYNC Events\r\n        const { communicationHub } = require('../services/CommunicationHub');\r\n        communicationHub.on('SYNC_COMPLETE', onSyncComplete);\r\n        communicationHub.on('SYNC_ERROR', onSyncError);\r\n\r\n        // 3. LISTEN FOR RECONNECT (Gap Fill Fix)\r\n        // If socket reconnects, we might have missed SYNC_COMPLETE.\r\n        // Force a SMART MERGE to ensure we are up to date.\r\n        const onReconnect = () => {\r\n            console.log(`[useChartData] ðŸ”Œ Socket Reconnected. Triggering Smart Merge check for ${symbol} ${timeframe}`);\r\n            // Check if we are ready (Status) or just blindly merge\r\n            if (lastCandleRef.current) {\r\n                fetchHistory(true); // Merge\r\n            }\r\n        };\r\n        communicationHub.on('connect', onReconnect);\r\n\r\n        // 4. LISTEN FOR STATUS UPDATES (Sanity)\r\n        const onSanityUpdate = (payload: any) => {\r\n            if (payload.symbol === symbol && payload.timeframe === timeframe) {\r\n                console.log(`[useChartData] ðŸš¦ Status Update: ${payload.status}`);\r\n                setSyncStatus(payload.status);\r\n            }\r\n        };\r\n        communicationHub.on('sanity_update', onSanityUpdate);\r\n\r\n        // 1. Check Initial Sync Status (Fix for Race Condition)\r\n        const checkSyncStatus = async () => {\r\n            try {\r\n                const res = await fetch(`http://127.0.0.1:3005/sync-status?symbol=${symbol}`);\r\n                const json = await res.json();\r\n                if (json.success && json.status) {\r\n                    // Check if specific TF is ready\r\n                    // Status structure: { \"M1\": { status: \"READY\", ... } }\r\n                    console.log(`[useChartData:Debug] /sync-status response for ${symbol}:`, JSON.stringify(json));\r\n                    const tfStatus = json.status[timeframe];\r\n\r\n                    if (tfStatus) {\r\n                        setSyncStatus(tfStatus.status); // <--- CRITICAL: Set initial status\r\n                    }\r\n\r\n                    if (tfStatus && (tfStatus.status === 'READY' || tfStatus.status === 'OFFLINE')) {\r\n                        console.log(`[useChartData] âœ… Initial Status Check: ${symbol} ${timeframe} is ALREADY READY.`);\r\n                        setIsChartReady(true);\r\n                    } else {\r\n                        console.log(`[useChartData] â³ Initial Status Check: ${symbol} ${timeframe} is ${tfStatus?.status || 'UNKNOWN'}. Showing available data while syncing...`);\r\n                        // Even if syncing, we show what we have!\r\n                    }\r\n                    // FIX: Always fetch available history immediately. Don't wait for Sync.\r\n                    fetchHistory();\r\n                }\r\n            } catch (e) {\r\n                console.warn(\"[useChartData] Failed to check sync status\", e);\r\n            }\r\n        };\r\n        checkSyncStatus();\r\n\r\n        // 2. Subscribe\r\n        const subId = `sub_${symbol}_${timeframe}_${Date.now()}`;\r\n        const adapter = datafeedRef.current;\r\n\r\n        if (adapter) {\r\n            adapter.subscribeBars(\r\n                { name: symbol },\r\n                timeframe,\r\n                (bar: any) => {\r\n                    // Realtime Logic (copied from LiveChartPage and simplified)\r\n                    if (bar.symbol !== symbol || bar.timeframe !== timeframe) return;\r\n\r\n                    const tfSeconds = getTimeframeSeconds(timeframe);\r\n                    let tickTime = Number(bar.time);\r\n                    if (tickTime > 100000000000) tickTime = tickTime / 1000;\r\n                    const candleTime = Math.floor(tickTime / tfSeconds) * tfSeconds;\r\n\r\n                    let candleToRender: any;\r\n\r\n                    if (!lastCandleRef.current) {\r\n                        // Fresh candle\r\n                        if (bar.open !== undefined) {\r\n                            // TRUSTED SOURCE (Full Candle)\r\n                            candleToRender = {\r\n                                time: candleTime,\r\n                                open: bar.open, high: bar.high, low: bar.low, close: bar.close, volume: bar.volume || 1\r\n                            };\r\n                        } else {\r\n                            // Raw Tick Construction\r\n                            candleToRender = {\r\n                                time: candleTime,\r\n                                open: bar.close, high: bar.close, low: bar.close, close: bar.close, volume: 1\r\n                            };\r\n                        }\r\n                        lastCandleRef.current = candleToRender;\r\n                    } else {\r\n                        if (candleTime > lastCandleRef.current.time) {\r\n                            // New Bar\r\n                            if (bar.open !== undefined) {\r\n                                candleToRender = {\r\n                                    time: candleTime,\r\n                                    open: bar.open, high: bar.high, low: bar.low, close: bar.close, volume: bar.volume || 1\r\n                                };\r\n                            } else {\r\n                                candleToRender = {\r\n                                    time: candleTime,\r\n                                    open: bar.close, high: bar.close, low: bar.close, close: bar.close, volume: 1\r\n                                };\r\n                            }\r\n                            lastCandleRef.current = candleToRender;\r\n                            setHorizonData(generatePhantomBars(candleTime, candleToRender.close, timeframe));\r\n                            lastCandleRef.current = candleToRender;\r\n                            setHorizonData(generatePhantomBars(candleTime, candleToRender.close, timeframe));\r\n                        } else if (candleTime === lastCandleRef.current.time) {\r\n                            // Update Existing (Strict Equality Check)\r\n                            if (bar.open !== undefined) {\r\n                                // TRUSTED UPDATE (Overwrite with Backend Truth)\r\n                                candleToRender = {\r\n                                    time: candleTime,\r\n                                    open: bar.open, high: bar.high, low: bar.low, close: bar.close, volume: bar.volume || 1\r\n                                };\r\n                            } else {\r\n                                // TICK UPDATE (Accumulate)\r\n                                const current = lastCandleRef.current;\r\n                                candleToRender = {\r\n                                    ...current,\r\n                                    close: bar.close,\r\n                                    high: Math.max(current.high, bar.close),\r\n                                    low: Math.min(current.low, bar.close),\r\n                                    volume: current.volume + 1\r\n                                };\r\n                            }\r\n                            lastCandleRef.current = candleToRender;\r\n                        } else {\r\n                            // OLD DATA -> IGNORE\r\n                            // This prevents \"Cannot update oldest data\" error in LWC\r\n                            // console.warn(`[useChartData] Generated time ${candleTime} is older than last ${lastCandleRef.current.time}. Ignoring.`);\r\n                            return;\r\n                        }\r\n                    }\r\n\r\n                    // Trigger callback for UI update\r\n                    if (onTick) {\r\n                        onTick(candleToRender);\r\n                    }\r\n                },\r\n                subId,\r\n                () => {\r\n                    // On History Signal (Gap Fill or Re-Sync)\r\n                    // SAFE NOW: Merge Logic prevents Flicker.\r\n                    console.log(\"[useChartData] ðŸ”„ History Signal received. Merging update...\");\r\n                    fetchHistory();\r\n                }\r\n            );\r\n        }\r\n\r\n        return () => {\r\n            if (adapter) adapter.unsubscribeBars(subId);\r\n            communicationHub.off('SYNC_COMPLETE', onSyncComplete);\r\n            communicationHub.off('SYNC_ERROR', onSyncError);\r\n            communicationHub.off('connect', onReconnect);\r\n            communicationHub.off('sanity_update', onSanityUpdate);\r\n        };\r\n\r\n    }, [symbol, timeframe, botId]);\r\n\r\n    // We return refs or a way to get the latest candle to avoid re-renders\r\n    return {\r\n        data,\r\n        horizonData,\r\n        isLoading,\r\n        isChartReady,\r\n        syncError,\r\n        syncStatus, // <--- Exposed\r\n        getLastCandle: () => lastCandleRef.current\r\n    };\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2300, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/hooks/ui/usePopoverPosition.ts"],"sourcesContent":["import { useState, useEffect, RefObject } from 'react';\r\n\r\ninterface PopoverPosition {\r\n    top: number;\r\n    left: number;\r\n    placement: 'top' | 'bottom';\r\n}\r\n\r\ninterface UsePopoverPositionProps<T extends HTMLElement> {\r\n    triggerRef: RefObject<T>;\r\n    contentHeight?: number; // Optional fallback\r\n    isOpen: boolean;\r\n    gap?: number;\r\n}\r\n\r\n/**\r\n * Calculates the optimal position for a popover (top or bottom) using dynamic height measurement.\r\n */\r\nexport const usePopoverPosition = <T extends HTMLElement>({\r\n    triggerRef,\r\n    contentHeight: defaultContentHeight = 300,\r\n    isOpen,\r\n    gap = 5\r\n}: UsePopoverPositionProps<T>) => {\r\n    const [position, setPosition] = useState<PopoverPosition>({ top: 0, left: 0, placement: 'bottom' });\r\n    const [contentElement, setContentElement] = useState<HTMLElement | null>(null);\r\n\r\n    // Callback ref for the content element\r\n    const contentRef = (node: HTMLElement | null) => {\r\n        setContentElement(node);\r\n    };\r\n\r\n    useEffect(() => {\r\n        if (!isOpen || !triggerRef.current) return;\r\n\r\n        const updatePosition = () => {\r\n            if (!triggerRef.current) return;\r\n\r\n            const rect = triggerRef.current.getBoundingClientRect();\r\n            const viewportHeight = window.innerHeight;\r\n\r\n            // Use actual measured height if available, otherwise fallback\r\n            const height = contentElement ? contentElement.offsetHeight : defaultContentHeight;\r\n            const spaceBelow = viewportHeight - rect.bottom;\r\n\r\n            let placement: 'top' | 'bottom' = 'bottom';\r\n            let top = rect.bottom + gap;\r\n\r\n            // Flip to top if insufficient space below\r\n            if (spaceBelow < height && rect.top > 50) {\r\n                placement = 'top';\r\n                // Position above: trigger top - content height - gap\r\n                top = rect.top - height - gap;\r\n            }\r\n\r\n            setPosition({\r\n                top,\r\n                left: rect.left,\r\n                placement\r\n            });\r\n        };\r\n\r\n        updatePosition();\r\n\r\n        window.addEventListener('resize', updatePosition);\r\n        window.addEventListener('scroll', updatePosition, true);\r\n\r\n        let observer: ResizeObserver | null = null;\r\n        if (contentElement) {\r\n            observer = new ResizeObserver(() => updatePosition());\r\n            observer.observe(contentElement);\r\n        }\r\n\r\n        return () => {\r\n            window.removeEventListener('resize', updatePosition);\r\n            window.removeEventListener('scroll', updatePosition, true);\r\n            if (observer) observer.disconnect();\r\n        };\r\n    }, [isOpen, defaultContentHeight, gap, contentElement]);\r\n\r\n    return { ...position, contentRef };\r\n};\r\n"],"names":[],"mappings":";;;;AAAA;;;AAkBO,MAAM,qBAAqB,CAAwB,EACtD,UAAU,EACV,eAAe,uBAAuB,GAAG,EACzC,MAAM,EACN,MAAM,CAAC,EACkB;;IACzB,MAAM,CAAC,UAAU,YAAY,GAAG,IAAA,yKAAQ,EAAkB;QAAE,KAAK;QAAG,MAAM;QAAG,WAAW;IAAS;IACjG,MAAM,CAAC,gBAAgB,kBAAkB,GAAG,IAAA,yKAAQ,EAAqB;IAEzE,uCAAuC;IACvC,MAAM,aAAa,CAAC;QAChB,kBAAkB;IACtB;IAEA,IAAA,0KAAS;wCAAC;YACN,IAAI,CAAC,UAAU,CAAC,WAAW,OAAO,EAAE;YAEpC,MAAM;+DAAiB;oBACnB,IAAI,CAAC,WAAW,OAAO,EAAE;oBAEzB,MAAM,OAAO,WAAW,OAAO,CAAC,qBAAqB;oBACrD,MAAM,iBAAiB,OAAO,WAAW;oBAEzC,8DAA8D;oBAC9D,MAAM,SAAS,iBAAiB,eAAe,YAAY,GAAG;oBAC9D,MAAM,aAAa,iBAAiB,KAAK,MAAM;oBAE/C,IAAI,YAA8B;oBAClC,IAAI,MAAM,KAAK,MAAM,GAAG;oBAExB,0CAA0C;oBAC1C,IAAI,aAAa,UAAU,KAAK,GAAG,GAAG,IAAI;wBACtC,YAAY;wBACZ,qDAAqD;wBACrD,MAAM,KAAK,GAAG,GAAG,SAAS;oBAC9B;oBAEA,YAAY;wBACR;wBACA,MAAM,KAAK,IAAI;wBACf;oBACJ;gBACJ;;YAEA;YAEA,OAAO,gBAAgB,CAAC,UAAU;YAClC,OAAO,gBAAgB,CAAC,UAAU,gBAAgB;YAElD,IAAI,WAAkC;YACtC,IAAI,gBAAgB;gBAChB,WAAW,IAAI;oDAAe,IAAM;;gBACpC,SAAS,OAAO,CAAC;YACrB;YAEA;gDAAO;oBACH,OAAO,mBAAmB,CAAC,UAAU;oBACrC,OAAO,mBAAmB,CAAC,UAAU,gBAAgB;oBACrD,IAAI,UAAU,SAAS,UAAU;gBACrC;;QACJ;uCAAG;QAAC;QAAQ;QAAsB;QAAK;KAAe;IAEtD,OAAO;QAAE,GAAG,QAAQ;QAAE;IAAW;AACrC;GA/Da"}},
    {"offset": {"line": 2382, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/stores/useBrokerStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { Broker } from '../lib/mt-manager/types';\r\n\r\ninterface BrokerStore {\r\n    brokers: Broker[];\r\n    isLoading: boolean;\r\n    error: string | null;\r\n    fetchBrokers: () => Promise<void>;\r\n    getBroker: (id: string) => Broker | undefined;\r\n}\r\n\r\nexport const useBrokerStore = create<BrokerStore>((set, get) => ({\r\n    brokers: [],\r\n    isLoading: false,\r\n    error: null,\r\n\r\n    fetchBrokers: async () => {\r\n        set({ isLoading: true, error: null });\r\n        try {\r\n            const res = await fetch('/api/brokers');\r\n            if (!res.ok) throw new Error('Failed to fetch brokers');\r\n            const data = await res.json();\r\n            set({ brokers: data, isLoading: false });\r\n        } catch (e: any) {\r\n            set({ error: e.message, isLoading: false });\r\n        }\r\n    },\r\n\r\n    getBroker: (id: string) => {\r\n        return get().brokers.find(b => b.id === id);\r\n    }\r\n}));\r\n"],"names":[],"mappings":";;;;AAAA;;AAWO,MAAM,iBAAiB,IAAA,qJAAM,EAAc,CAAC,KAAK,MAAQ,CAAC;QAC7D,SAAS,EAAE;QACX,WAAW;QACX,OAAO;QAEP,cAAc;YACV,IAAI;gBAAE,WAAW;gBAAM,OAAO;YAAK;YACnC,IAAI;gBACA,MAAM,MAAM,MAAM,MAAM;gBACxB,IAAI,CAAC,IAAI,EAAE,EAAE,MAAM,IAAI,MAAM;gBAC7B,MAAM,OAAO,MAAM,IAAI,IAAI;gBAC3B,IAAI;oBAAE,SAAS;oBAAM,WAAW;gBAAM;YAC1C,EAAE,OAAO,GAAQ;gBACb,IAAI;oBAAE,OAAO,EAAE,OAAO;oBAAE,WAAW;gBAAM;YAC7C;QACJ;QAEA,WAAW,CAAC;YACR,OAAO,MAAM,OAAO,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;QAC5C;IACJ,CAAC"}},
    {"offset": {"line": 2423, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/stores/useWorkspaceStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { persist, createJSONStorage } from 'zustand/middleware';\r\nimport { v4 as uuidv4 } from 'uuid';\r\n\r\nexport type LayoutType = 'single' | 'split-vertical' | 'split-horizontal' | 'grid-2x2' | 'grid-1-2';\r\n\r\n\r\nexport interface SavedIndicator {\r\n    instanceId: string;\r\n    defId: string;\r\n    settings: any;\r\n    visible: boolean;\r\n}\r\n\r\nexport interface PaneConfig {\r\n    id: string;\r\n    symbol: string;\r\n    timeframe: string;\r\n    isActive: boolean;\r\n    indicators?: SavedIndicator[];\r\n    drawings?: string; // Serialized JSON of chart shapes\r\n    scrollToTimeRequest?: { id: string, time: number };\r\n}\r\n\r\nexport interface Workspace {\r\n    id: string;\r\n    name: string;\r\n    layoutType: LayoutType;\r\n    layoutSizes: number[];\r\n    panes: PaneConfig[];\r\n    maximizedPaneId?: string; // ID of the maximized pane, if any\r\n}\r\n\r\ninterface WorkspaceState {\r\n    workspaces: Workspace[];\r\n    activeWorkspaceId: string;\r\n\r\n    // Actions\r\n    addWorkspace: (name?: string) => void;\r\n    removeWorkspace: (id: string) => void;\r\n    setActiveWorkspace: (id: string) => void;\r\n    updateWorkspaceLayout: (workspaceId: string, layout: LayoutType) => void;\r\n    updateLayoutSizes: (workspaceId: string, sizes: number[]) => void;\r\n    toggleMaximizePane: (workspaceId: string, paneId: string) => void;\r\n\r\n    // Test Mode\r\n    isTestMode: boolean;\r\n    toggleTestMode: () => void;\r\n    setIsTestMode: (mode: boolean) => void;\r\n\r\n    // Pane Management\r\n    updatePane: (workspaceId: string, paneId: string, updates: Partial<PaneConfig>) => void;\r\n    setActivePane: (workspaceId: string, paneId: string) => void;\r\n    requestScrollToTime: (paneId: string, time: number) => void;\r\n}\r\n\r\n// ... existing code ...\r\n\r\nconst createDefaultPaneConfig = (): Omit<PaneConfig, 'id' | 'isActive'> => ({\r\n    symbol: 'BTCUSD',\r\n    timeframe: 'D1',\r\n    indicators: [] // New array reference every time\r\n});\r\n\r\nconst createDefaultWorkspace = (name: string): Workspace => {\r\n    const paneId = uuidv4();\r\n    return {\r\n        id: uuidv4(),\r\n        name,\r\n        layoutType: 'single',\r\n        layoutSizes: [],\r\n        panes: [{ ...createDefaultPaneConfig(), id: paneId, isActive: true }]\r\n    };\r\n};\r\n\r\nexport const useWorkspaceStore = create<WorkspaceState>()(\r\n    persist(\r\n        (set, get) => ({\r\n            workspaces: [createDefaultWorkspace('Main Workspace')],\r\n            activeWorkspaceId: '', // Set in initial hydration if empty? Actually we'll ensure at least one exists.\r\n\r\n            isTestMode: true, // Default to Safe Mode\r\n\r\n            toggleTestMode: () => set((state) => ({ isTestMode: !state.isTestMode })),\r\n            setIsTestMode: (mode) => set({ isTestMode: mode }),\r\n\r\n            addWorkspace: (name = 'New Workspace') => {\r\n                const newWorkspace = createDefaultWorkspace(name);\r\n                set((state) => ({\r\n                    workspaces: [...state.workspaces, newWorkspace],\r\n                    activeWorkspaceId: newWorkspace.id\r\n                }));\r\n            },\r\n\r\n            removeWorkspace: (id) => {\r\n                set((state) => {\r\n                    const filtered = state.workspaces.filter(w => w.id !== id);\r\n                    // If we removed the active one, switch to the first available\r\n                    let newActiveId = state.activeWorkspaceId;\r\n                    if (id === state.activeWorkspaceId) {\r\n                        newActiveId = filtered.length > 0 ? filtered[0].id : '';\r\n                    }\r\n\r\n                    // Prevent empty workspaces list?\r\n                    if (filtered.length === 0) {\r\n                        const fallback = createDefaultWorkspace('Default');\r\n                        return { workspaces: [fallback], activeWorkspaceId: fallback.id };\r\n                    }\r\n\r\n                    return { workspaces: filtered, activeWorkspaceId: newActiveId };\r\n                });\r\n            },\r\n\r\n            setActiveWorkspace: (id) => set({ activeWorkspaceId: id }),\r\n\r\n            updateWorkspaceLayout: (workspaceId, layout) => {\r\n                set((state) => {\r\n                    return {\r\n                        workspaces: state.workspaces.map(w => {\r\n                            if (w.id !== workspaceId) return w;\r\n\r\n                            // Adjust panes based on layout\r\n                            let newPanes = [...w.panes];\r\n                            // Determine target pane count\r\n                            let targetCount = 1;\r\n                            let defaultSizes: number[] = [];\r\n\r\n                            switch (layout) {\r\n                                case 'single':\r\n                                    targetCount = 1;\r\n                                    defaultSizes = [100];\r\n                                    break;\r\n                                case 'split-vertical':\r\n                                case 'split-horizontal':\r\n                                    targetCount = 2;\r\n                                    defaultSizes = [50, 50];\r\n                                    break;\r\n                                case 'grid-1-2':\r\n                                    targetCount = 3;\r\n                                    // Main Split (66/33), Right Split (50/50)\r\n                                    // [MainL, MainR, RightTop, RightBot]\r\n                                    defaultSizes = [66, 34, 50, 50];\r\n                                    break;\r\n                                case 'grid-2x2':\r\n                                    targetCount = 4;\r\n                                    // Main Split (50/50), Left Split (50/50), Right Split (50/50)\r\n                                    // [MainL, MainR, LeftTop, LeftBot, RightTop, RightBot]\r\n                                    defaultSizes = [50, 50, 50, 50, 50, 50];\r\n                                    break;\r\n                            }\r\n\r\n                            if (newPanes.length < targetCount) {\r\n                                // Add panes\r\n                                const needed = targetCount - newPanes.length;\r\n                                for (let i = 0; i < needed; i++) {\r\n                                    newPanes.push({\r\n                                        ...createDefaultPaneConfig(),\r\n                                        id: uuidv4(),\r\n                                        isActive: false,\r\n                                        // Copy symbol from active pane if possible?\r\n                                        symbol: w.panes.find(p => p.isActive)?.symbol || createDefaultPaneConfig().symbol\r\n                                    });\r\n                                }\r\n                            } else if (newPanes.length > targetCount) {\r\n                                // Remove panes (keep active one if possible, or first ones)\r\n                                // Better strategy: Keep the first N panes\r\n                                newPanes = newPanes.slice(0, targetCount);\r\n                                // Ensure one is active\r\n                                if (!newPanes.find(p => p.isActive)) {\r\n                                    newPanes[0].isActive = true;\r\n                                }\r\n                            }\r\n\r\n                            return { ...w, layoutType: layout, panes: newPanes, layoutSizes: defaultSizes };\r\n                        })\r\n                    };\r\n                });\r\n            },\r\n\r\n            updateLayoutSizes: (workspaceId, sizes) => {\r\n                set((state) => ({\r\n                    workspaces: state.workspaces.map(w => {\r\n                        if (w.id !== workspaceId) return w;\r\n                        return { ...w, layoutSizes: sizes };\r\n                    })\r\n                }));\r\n            },\r\n\r\n            toggleMaximizePane: (workspaceId, paneId) => {\r\n                set((state) => ({\r\n                    workspaces: state.workspaces.map(w => {\r\n                        if (w.id !== workspaceId) return w;\r\n                        const isCurrentlyMaximized = w.maximizedPaneId === paneId;\r\n                        return {\r\n                            ...w,\r\n                            maximizedPaneId: isCurrentlyMaximized ? undefined : paneId\r\n                        };\r\n                    })\r\n                }));\r\n            },\r\n\r\n            updatePane: (workspaceId, paneId, updates) => {\r\n                set((state) => ({\r\n                    workspaces: state.workspaces.map(w => {\r\n                        if (w.id !== workspaceId) return w;\r\n                        return {\r\n                            ...w,\r\n                            panes: w.panes.map(p => p.id === paneId ? { ...p, ...updates } : p)\r\n                        };\r\n                    })\r\n                }));\r\n            },\r\n\r\n            setActivePane: (workspaceId, paneId) => {\r\n                set((state) => ({\r\n                    workspaces: state.workspaces.map(w => {\r\n                        if (w.id !== workspaceId) return w;\r\n                        return {\r\n                            ...w,\r\n                            panes: w.panes.map(p => ({ ...p, isActive: p.id === paneId }))\r\n                        };\r\n                    })\r\n                }));\r\n            },\r\n\r\n            requestScrollToTime: (paneId, time) => {\r\n                set((state) => ({\r\n                    workspaces: state.workspaces.map(w => {\r\n                        // Find workspace containing this pane\r\n                        const hasPane = w.panes.some(p => p.id === paneId);\r\n                        if (!hasPane) return w;\r\n\r\n                        return {\r\n                            ...w,\r\n                            panes: w.panes.map(p => {\r\n                                if (p.id !== paneId) return p;\r\n                                return {\r\n                                    ...p,\r\n                                    scrollToTimeRequest: {\r\n                                        id: uuidv4(), // Unique ID to force effect trigger even if time is same\r\n                                        time\r\n                                    }\r\n                                };\r\n                            })\r\n                        };\r\n                    })\r\n                }));\r\n            }\r\n        }),\r\n        {\r\n            name: 'workspace-storage',\r\n            storage: createJSONStorage(() => localStorage),\r\n            onRehydrateStorage: () => (state) => {\r\n                // Ensure activeWorkspaceId is valid on load\r\n                if (state && state.workspaces.length > 0 && !state.activeWorkspaceId) {\r\n                    state.activeWorkspaceId = state.workspaces[0].id;\r\n                }\r\n            }\r\n        }\r\n    )\r\n);\r\n"],"names":[],"mappings":";;;;AAAA;AACA;AACA;;;;AAsDA,wBAAwB;AAExB,MAAM,0BAA0B,IAA2C,CAAC;QACxE,QAAQ;QACR,WAAW;QACX,YAAY,EAAE,CAAC,iCAAiC;IACpD,CAAC;AAED,MAAM,yBAAyB,CAAC;IAC5B,MAAM,SAAS,IAAA,4KAAM;IACrB,OAAO;QACH,IAAI,IAAA,4KAAM;QACV;QACA,YAAY;QACZ,aAAa,EAAE;QACf,OAAO;YAAC;gBAAE,GAAG,yBAAyB;gBAAE,IAAI;gBAAQ,UAAU;YAAK;SAAE;IACzE;AACJ;AAEO,MAAM,oBAAoB,IAAA,qJAAM,IACnC,IAAA,2JAAO,EACH,CAAC,KAAK,MAAQ,CAAC;QACX,YAAY;YAAC,uBAAuB;SAAkB;QACtD,mBAAmB;QAEnB,YAAY;QAEZ,gBAAgB,IAAM,IAAI,CAAC,QAAU,CAAC;oBAAE,YAAY,CAAC,MAAM,UAAU;gBAAC,CAAC;QACvE,eAAe,CAAC,OAAS,IAAI;gBAAE,YAAY;YAAK;QAEhD,cAAc,CAAC,OAAO,eAAe;YACjC,MAAM,eAAe,uBAAuB;YAC5C,IAAI,CAAC,QAAU,CAAC;oBACZ,YAAY;2BAAI,MAAM,UAAU;wBAAE;qBAAa;oBAC/C,mBAAmB,aAAa,EAAE;gBACtC,CAAC;QACL;QAEA,iBAAiB,CAAC;YACd,IAAI,CAAC;gBACD,MAAM,WAAW,MAAM,UAAU,CAAC,MAAM,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;gBACvD,8DAA8D;gBAC9D,IAAI,cAAc,MAAM,iBAAiB;gBACzC,IAAI,OAAO,MAAM,iBAAiB,EAAE;oBAChC,cAAc,SAAS,MAAM,GAAG,IAAI,QAAQ,CAAC,EAAE,CAAC,EAAE,GAAG;gBACzD;gBAEA,iCAAiC;gBACjC,IAAI,SAAS,MAAM,KAAK,GAAG;oBACvB,MAAM,WAAW,uBAAuB;oBACxC,OAAO;wBAAE,YAAY;4BAAC;yBAAS;wBAAE,mBAAmB,SAAS,EAAE;oBAAC;gBACpE;gBAEA,OAAO;oBAAE,YAAY;oBAAU,mBAAmB;gBAAY;YAClE;QACJ;QAEA,oBAAoB,CAAC,KAAO,IAAI;gBAAE,mBAAmB;YAAG;QAExD,uBAAuB,CAAC,aAAa;YACjC,IAAI,CAAC;gBACD,OAAO;oBACH,YAAY,MAAM,UAAU,CAAC,GAAG,CAAC,CAAA;wBAC7B,IAAI,EAAE,EAAE,KAAK,aAAa,OAAO;wBAEjC,+BAA+B;wBAC/B,IAAI,WAAW;+BAAI,EAAE,KAAK;yBAAC;wBAC3B,8BAA8B;wBAC9B,IAAI,cAAc;wBAClB,IAAI,eAAyB,EAAE;wBAE/B,OAAQ;4BACJ,KAAK;gCACD,cAAc;gCACd,eAAe;oCAAC;iCAAI;gCACpB;4BACJ,KAAK;4BACL,KAAK;gCACD,cAAc;gCACd,eAAe;oCAAC;oCAAI;iCAAG;gCACvB;4BACJ,KAAK;gCACD,cAAc;gCACd,0CAA0C;gCAC1C,qCAAqC;gCACrC,eAAe;oCAAC;oCAAI;oCAAI;oCAAI;iCAAG;gCAC/B;4BACJ,KAAK;gCACD,cAAc;gCACd,8DAA8D;gCAC9D,uDAAuD;gCACvD,eAAe;oCAAC;oCAAI;oCAAI;oCAAI;oCAAI;oCAAI;iCAAG;gCACvC;wBACR;wBAEA,IAAI,SAAS,MAAM,GAAG,aAAa;4BAC/B,YAAY;4BACZ,MAAM,SAAS,cAAc,SAAS,MAAM;4BAC5C,IAAK,IAAI,IAAI,GAAG,IAAI,QAAQ,IAAK;gCAC7B,SAAS,IAAI,CAAC;oCACV,GAAG,yBAAyB;oCAC5B,IAAI,IAAA,4KAAM;oCACV,UAAU;oCACV,4CAA4C;oCAC5C,QAAQ,EAAE,KAAK,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,QAAQ,GAAG,UAAU,0BAA0B,MAAM;gCACrF;4BACJ;wBACJ,OAAO,IAAI,SAAS,MAAM,GAAG,aAAa;4BACtC,4DAA4D;4BAC5D,0CAA0C;4BAC1C,WAAW,SAAS,KAAK,CAAC,GAAG;4BAC7B,uBAAuB;4BACvB,IAAI,CAAC,SAAS,IAAI,CAAC,CAAA,IAAK,EAAE,QAAQ,GAAG;gCACjC,QAAQ,CAAC,EAAE,CAAC,QAAQ,GAAG;4BAC3B;wBACJ;wBAEA,OAAO;4BAAE,GAAG,CAAC;4BAAE,YAAY;4BAAQ,OAAO;4BAAU,aAAa;wBAAa;oBAClF;gBACJ;YACJ;QACJ;QAEA,mBAAmB,CAAC,aAAa;YAC7B,IAAI,CAAC,QAAU,CAAC;oBACZ,YAAY,MAAM,UAAU,CAAC,GAAG,CAAC,CAAA;wBAC7B,IAAI,EAAE,EAAE,KAAK,aAAa,OAAO;wBACjC,OAAO;4BAAE,GAAG,CAAC;4BAAE,aAAa;wBAAM;oBACtC;gBACJ,CAAC;QACL;QAEA,oBAAoB,CAAC,aAAa;YAC9B,IAAI,CAAC,QAAU,CAAC;oBACZ,YAAY,MAAM,UAAU,CAAC,GAAG,CAAC,CAAA;wBAC7B,IAAI,EAAE,EAAE,KAAK,aAAa,OAAO;wBACjC,MAAM,uBAAuB,EAAE,eAAe,KAAK;wBACnD,OAAO;4BACH,GAAG,CAAC;4BACJ,iBAAiB,uBAAuB,YAAY;wBACxD;oBACJ;gBACJ,CAAC;QACL;QAEA,YAAY,CAAC,aAAa,QAAQ;YAC9B,IAAI,CAAC,QAAU,CAAC;oBACZ,YAAY,MAAM,UAAU,CAAC,GAAG,CAAC,CAAA;wBAC7B,IAAI,EAAE,EAAE,KAAK,aAAa,OAAO;wBACjC,OAAO;4BACH,GAAG,CAAC;4BACJ,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK,SAAS;oCAAE,GAAG,CAAC;oCAAE,GAAG,OAAO;gCAAC,IAAI;wBACrE;oBACJ;gBACJ,CAAC;QACL;QAEA,eAAe,CAAC,aAAa;YACzB,IAAI,CAAC,QAAU,CAAC;oBACZ,YAAY,MAAM,UAAU,CAAC,GAAG,CAAC,CAAA;wBAC7B,IAAI,EAAE,EAAE,KAAK,aAAa,OAAO;wBACjC,OAAO;4BACH,GAAG,CAAC;4BACJ,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,CAAA,IAAK,CAAC;oCAAE,GAAG,CAAC;oCAAE,UAAU,EAAE,EAAE,KAAK;gCAAO,CAAC;wBAChE;oBACJ;gBACJ,CAAC;QACL;QAEA,qBAAqB,CAAC,QAAQ;YAC1B,IAAI,CAAC,QAAU,CAAC;oBACZ,YAAY,MAAM,UAAU,CAAC,GAAG,CAAC,CAAA;wBAC7B,sCAAsC;wBACtC,MAAM,UAAU,EAAE,KAAK,CAAC,IAAI,CAAC,CAAA,IAAK,EAAE,EAAE,KAAK;wBAC3C,IAAI,CAAC,SAAS,OAAO;wBAErB,OAAO;4BACH,GAAG,CAAC;4BACJ,OAAO,EAAE,KAAK,CAAC,GAAG,CAAC,CAAA;gCACf,IAAI,EAAE,EAAE,KAAK,QAAQ,OAAO;gCAC5B,OAAO;oCACH,GAAG,CAAC;oCACJ,qBAAqB;wCACjB,IAAI,IAAA,4KAAM;wCACV;oCACJ;gCACJ;4BACJ;wBACJ;oBACJ;gBACJ,CAAC;QACL;IACJ,CAAC,GACD;IACI,MAAM;IACN,SAAS,IAAA,qKAAiB,EAAC,IAAM;IACjC,oBAAoB,IAAM,CAAC;YACvB,4CAA4C;YAC5C,IAAI,SAAS,MAAM,UAAU,CAAC,MAAM,GAAG,KAAK,CAAC,MAAM,iBAAiB,EAAE;gBAClE,MAAM,iBAAiB,GAAG,MAAM,UAAU,CAAC,EAAE,CAAC,EAAE;YACpD;QACJ;AACJ"}},
    {"offset": {"line": 2677, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/stores/useChartRegistryStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { ChartContainerHandle } from '../components/charts/ChartContainer';\r\n\r\ninterface ChartRegistryState {\r\n    charts: Record<string, ChartContainerHandle>;\r\n    registerChart: (paneId: string, handle: ChartContainerHandle) => void;\r\n    unregisterChart: (paneId: string) => void;\r\n    getChart: (paneId: string) => ChartContainerHandle | null;\r\n}\r\n\r\nexport const useChartRegistryStore = create<ChartRegistryState>((set, get) => ({\r\n    charts: {},\r\n    registerChart: (paneId, handle) => {\r\n        set((state) => ({\r\n            charts: { ...state.charts, [paneId]: handle }\r\n        }));\r\n    },\r\n    unregisterChart: (paneId) => {\r\n        set((state) => {\r\n            const { [paneId]: removed, ...rest } = state.charts;\r\n            return { charts: rest };\r\n        });\r\n    },\r\n    getChart: (paneId) => {\r\n        return get().charts[paneId] || null;\r\n    }\r\n}));\r\n"],"names":[],"mappings":";;;;AAAA;;AAUO,MAAM,wBAAwB,IAAA,qJAAM,EAAqB,CAAC,KAAK,MAAQ,CAAC;QAC3E,QAAQ,CAAC;QACT,eAAe,CAAC,QAAQ;YACpB,IAAI,CAAC,QAAU,CAAC;oBACZ,QAAQ;wBAAE,GAAG,MAAM,MAAM;wBAAE,CAAC,OAAO,EAAE;oBAAO;gBAChD,CAAC;QACL;QACA,iBAAiB,CAAC;YACd,IAAI,CAAC;gBACD,MAAM,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,GAAG,MAAM,GAAG,MAAM,MAAM;gBACnD,OAAO;oBAAE,QAAQ;gBAAK;YAC1B;QACJ;QACA,UAAU,CAAC;YACP,OAAO,MAAM,MAAM,CAAC,OAAO,IAAI;QACnC;IACJ,CAAC"}},
    {"offset": {"line": 2712, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/stores/useSymbolStore.ts"],"sourcesContent":["import { create } from 'zustand';\r\nimport { fetchSymbols } from '../services/api';\r\n\r\nexport interface SymbolInfo {\r\n    symbol: string;\r\n    description?: string;\r\n    digits: number;\r\n    path?: string[];\r\n    exchange?: string;\r\n    type?: string;\r\n}\r\n\r\ninterface SymbolStore {\r\n    symbols: string[];\r\n    symbolMap: Map<string, SymbolInfo>; // Fast lookup\r\n    isLoading: boolean;\r\n    error: string | null;\r\n\r\n    // Actions\r\n    fetchSymbols: (botId?: string) => Promise<void>;\r\n    getSymbolInfo: (symbol: string) => SymbolInfo | undefined;\r\n}\r\n\r\n// Initial fetch prevention\r\nlet isFetching = false;\r\n\r\nexport const useSymbolStore = create<SymbolStore>((set, get) => ({\r\n    symbols: [],\r\n    symbolMap: new Map(),\r\n    isLoading: false,\r\n    error: null,\r\n\r\n    fetchSymbols: async (botId) => {\r\n        // Simple cache check: if we have symbols and not explicitly refreshing (TODO: add force refresh param if needed)\r\n        // For now, allow refetch if botId changes or empty\r\n        const currentCount = get().symbols.length;\r\n        if (currentCount > 0 && !botId) return;\r\n\r\n        if (isFetching) return;\r\n        isFetching = true;\r\n\r\n        set({ isLoading: true, error: null });\r\n\r\n        try {\r\n            // fetchSymbols now returns enriched objects from the API (SocketServer)\r\n            // api.ts fetchSymbols returns string[] OR object? \r\n            // We need to check api.ts. If it returns strings, we are stuck.\r\n            // Let's assume we update api.ts or it already returns what SocketServer /symbols endpoint sends (which is objects now)\r\n\r\n            // Checking api.ts logic in mind: \r\n            // It calls /symbols. SocketServer /symbols returns an array of objects enriched with digits.\r\n            // But api.ts logic might flatten it? \r\n            // Let's rely on the raw response structure we saw in SocketServer code.\r\n\r\n            const result = await fetchSymbols(botId);\r\n\r\n            const map = new Map<string, SymbolInfo>();\r\n            const list: string[] = [];\r\n\r\n            // Helper to parse result\r\n            // The API might return strings or objects depending on the fallback.\r\n            // We should handle both.\r\n\r\n            // Note: fetchSymbols in api.ts is typed to return Promise<string[]> but implementation returns data.symbols which is object array.\r\n            // We'll cast it here.\r\n\r\n            const rawItems = result as any[];\r\n\r\n            rawItems.forEach((item: any) => {\r\n                if (typeof item === 'string') {\r\n                    // Fallback\r\n                    list.push(item);\r\n                    map.set(item, { symbol: item, digits: 5 }); // Default 5\r\n                } else {\r\n                    const sym = item.name || item.symbol;\r\n                    if (sym) {\r\n                        list.push(sym);\r\n                        map.set(sym, {\r\n                            symbol: sym,\r\n                            description: item.description || item.desc || '',\r\n                            digits: item.digits !== undefined ? item.digits : 5,\r\n                            path: item.path,\r\n                            exchange: item.exchange,\r\n                            type: item.type\r\n                        });\r\n                    }\r\n                }\r\n            });\r\n\r\n            list.sort();\r\n\r\n            set({ symbols: list, symbolMap: map, isLoading: false });\r\n        } catch (e: any) {\r\n            set({ error: e.message, isLoading: false });\r\n        } finally {\r\n            isFetching = false;\r\n        }\r\n    },\r\n\r\n    getSymbolInfo: (symbol) => {\r\n        return get().symbolMap.get(symbol);\r\n    }\r\n}));\r\n"],"names":[],"mappings":";;;;AAAA;AACA;;;AAsBA,2BAA2B;AAC3B,IAAI,aAAa;AAEV,MAAM,iBAAiB,IAAA,qJAAM,EAAc,CAAC,KAAK,MAAQ,CAAC;QAC7D,SAAS,EAAE;QACX,WAAW,IAAI;QACf,WAAW;QACX,OAAO;QAEP,cAAc,OAAO;YACjB,iHAAiH;YACjH,mDAAmD;YACnD,MAAM,eAAe,MAAM,OAAO,CAAC,MAAM;YACzC,IAAI,eAAe,KAAK,CAAC,OAAO;YAEhC,IAAI,YAAY;YAChB,aAAa;YAEb,IAAI;gBAAE,WAAW;gBAAM,OAAO;YAAK;YAEnC,IAAI;gBACA,wEAAwE;gBACxE,mDAAmD;gBACnD,gEAAgE;gBAChE,uHAAuH;gBAEvH,kCAAkC;gBAClC,6FAA6F;gBAC7F,sCAAsC;gBACtC,wEAAwE;gBAExE,MAAM,SAAS,MAAM,IAAA,yIAAY,EAAC;gBAElC,MAAM,MAAM,IAAI;gBAChB,MAAM,OAAiB,EAAE;gBAEzB,yBAAyB;gBACzB,qEAAqE;gBACrE,yBAAyB;gBAEzB,mIAAmI;gBACnI,sBAAsB;gBAEtB,MAAM,WAAW;gBAEjB,SAAS,OAAO,CAAC,CAAC;oBACd,IAAI,OAAO,SAAS,UAAU;wBAC1B,WAAW;wBACX,KAAK,IAAI,CAAC;wBACV,IAAI,GAAG,CAAC,MAAM;4BAAE,QAAQ;4BAAM,QAAQ;wBAAE,IAAI,YAAY;oBAC5D,OAAO;wBACH,MAAM,MAAM,KAAK,IAAI,IAAI,KAAK,MAAM;wBACpC,IAAI,KAAK;4BACL,KAAK,IAAI,CAAC;4BACV,IAAI,GAAG,CAAC,KAAK;gCACT,QAAQ;gCACR,aAAa,KAAK,WAAW,IAAI,KAAK,IAAI,IAAI;gCAC9C,QAAQ,KAAK,MAAM,KAAK,YAAY,KAAK,MAAM,GAAG;gCAClD,MAAM,KAAK,IAAI;gCACf,UAAU,KAAK,QAAQ;gCACvB,MAAM,KAAK,IAAI;4BACnB;wBACJ;oBACJ;gBACJ;gBAEA,KAAK,IAAI;gBAET,IAAI;oBAAE,SAAS;oBAAM,WAAW;oBAAK,WAAW;gBAAM;YAC1D,EAAE,OAAO,GAAQ;gBACb,IAAI;oBAAE,OAAO,EAAE,OAAO;oBAAE,WAAW;gBAAM;YAC7C,SAAU;gBACN,aAAa;YACjB;QACJ;QAEA,eAAe,CAAC;YACZ,OAAO,MAAM,SAAS,CAAC,GAAG,CAAC;QAC/B;IACJ,CAAC"}},
    {"offset": {"line": 2805, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/stores/LayoutStateManager.ts"],"sourcesContent":["/**\r\n * LayoutStateManager.ts\r\n * \r\n * Logic Implementation for the Multi-Chart Sync Engine.\r\n * \r\n * RESPONSIBILITIES:\r\n * 1. Maintain synchronization state (Timeframe enabled? Position enabled?)\r\n * 2. Registry of active ChartPanes (via ChartHandle interface).\r\n * 3. Broadcast events from Source -> Targets (excluding Source).\r\n */\r\n\r\nexport interface SyncOptions {\r\n    isTimeframeSync: boolean;\r\n    isPositionSync: boolean;\r\n}\r\n\r\nexport interface ChartHandle {\r\n    // Unique identifier of the pane\r\n    id: string;\r\n\r\n    // Apply a new timeframe to this chart\r\n    setTimeframe(tf: string): void;\r\n\r\n    // Get current timeframe\r\n    getTimeframe(): string;\r\n\r\n    // Scroll the chart to a specific time range\r\n    setVisibleRange(range: { from: number; to: number }): void;\r\n\r\n    // Set logical range (for more precise sync without autoScale loops)\r\n    setLogicalRange(range: { from: number; to: number, anchorTime?: number, whitespaceOffset?: number }): void;\r\n\r\n    // Move the crosshair to a specific time/price point\r\n    setCrosshair(time: number, price?: number): void;\r\n}\r\n\r\nexport class LayoutStateManager {\r\n    // Singleton Instance\r\n    private static instance: LayoutStateManager;\r\n\r\n    // Internal State\r\n    private charts: Map<string, ChartHandle> = new Map();\r\n\r\n\r\n    private options: SyncOptions = {\r\n        isTimeframeSync: false,\r\n        isPositionSync: false\r\n    };\r\n\r\n    private lastActiveChartId: string | null = null;\r\n\r\n    private constructor() {\r\n        console.log(\"[LayoutStateManager] Initialized\");\r\n    }\r\n\r\n    public static getInstance(): LayoutStateManager {\r\n        if (!LayoutStateManager.instance) {\r\n            LayoutStateManager.instance = new LayoutStateManager();\r\n        }\r\n        return LayoutStateManager.instance;\r\n    }\r\n\r\n    /**\r\n     * Updates the synchronization configuration.\r\n     * @param options Partial options to update\r\n     */\r\n    public setOptions(options: Partial<SyncOptions>): void {\r\n        const prevTimeframeSync = this.options.isTimeframeSync;\r\n\r\n        this.options = { ...this.options, ...options };\r\n        console.log(\"[LayoutStateManager] Options updated:\", this.options);\r\n\r\n        // Logic 1: Initial Sync Logic (Timeframe)\r\n        if (!prevTimeframeSync && this.options.isTimeframeSync) {\r\n            this.applyMasterTimeToAll();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the \"Active\" chart (Master for next sync operation)\r\n     */\r\n    public setLastActive(id: string): void {\r\n        this.lastActiveChartId = id;\r\n    }\r\n\r\n    /**\r\n     * Hydrates all charts with the timeframe of the master chart\r\n     */\r\n    private applyMasterTimeToAll(): void {\r\n        // Determine Master: Last Active or First registered\r\n        let masterId = this.lastActiveChartId;\r\n        if (!masterId || !this.charts.has(masterId)) {\r\n            const first = this.charts.keys().next().value;\r\n            if (first) masterId = first;\r\n        }\r\n\r\n        if (!masterId) return; // No charts registered\r\n\r\n        const masterHandle = this.charts.get(masterId);\r\n        if (masterHandle) {\r\n            const masterTf = masterHandle.getTimeframe();\r\n            console.log(`[LayoutStateManager] Initial Sync from Master (${masterId}): ${masterTf}`);\r\n            this.syncTimeframe(masterId, masterTf);\r\n        }\r\n    }\r\n\r\n    public getOptions(): SyncOptions {\r\n        return { ...this.options };\r\n    }\r\n\r\n    /**\r\n     * Registers a chart instance for synchronization.\r\n     * @param handle The interface to control the chart\r\n     */\r\n    public register(handle: ChartHandle): void {\r\n        if (!this.charts.has(handle.id)) {\r\n            console.log(`[LayoutStateManager] Registering chart: ${handle.id}`);\r\n            this.charts.set(handle.id, handle);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes a chart from the registry.\r\n     * @param id The ID of the chart to remove\r\n     */\r\n    public unregister(id: string): void {\r\n        if (this.charts.has(id)) {\r\n            this.charts.delete(id);\r\n            if (this.lastActiveChartId === id) {\r\n                this.lastActiveChartId = null;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Broadcasts a timeframe change to all other charts (if Sync active).\r\n     * @param sourceId The ID of the chart initiating the change\r\n     * @param timeframe The new timeframe (e.g. \"M5\")\r\n     */\r\n    public syncTimeframe(sourceId: string, timeframe: string): void {\r\n        if (!this.options.isTimeframeSync) return;\r\n\r\n        this.charts.forEach((handle, id) => {\r\n            if (id !== sourceId) {\r\n                handle.setTimeframe(timeframe);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Broadcasts a visible range scroll update (if Sync active).\r\n     * @param sourceId The ID of the chart initiating the scroll\r\n     * @param range The new visible time range\r\n     * @param logicalRange Optional logical range for precise sync\r\n     */\r\n    public syncScroll(sourceId: string, range: { from: number; to: number }, logicalRange?: { from: number; to: number, anchorTime?: number, whitespaceOffset?: number }): void {\r\n        if (!this.options.isPositionSync) return;\r\n\r\n        this.charts.forEach((handle, id) => {\r\n            if (id !== sourceId) {\r\n                if (logicalRange) {\r\n                    handle.setLogicalRange(logicalRange);\r\n                } else {\r\n                    handle.setVisibleRange(range);\r\n                }\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Broadcasts a crosshair move (if Sync active).\r\n     * WARNING: Hot path! Must use requestAnimationFrame or direct calls to avoid GC/Lag.\r\n     * @param sourceId The ID of the chart where the mouse is\r\n     * @param time The time index under the mouse\r\n     * @param price The price level (optional)\r\n     */\r\n    public syncCrosshair(sourceId: string, time: number, price: number): void {\r\n        if (!this.options.isPositionSync) return;\r\n\r\n        // Direct iteration for max performance\r\n        // Bypass React state updates, call the handle directly\r\n        for (const [id, handle] of this.charts) {\r\n            if (id !== sourceId) {\r\n                handle.setCrosshair(time, price);\r\n            }\r\n        }\r\n    }\r\n\r\n    // --- Persistence Methods ---\r\n\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 2952, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/managers/TradeDistributionManager.ts"],"sourcesContent":["import { TradingAccount, Broker } from '../lib/mt-manager/types';\r\n\r\ninterface DistributionConfig {\r\n    brokers: {\r\n        [brokerId: string]: {\r\n            loop_size: number;\r\n            matrix: {\r\n                [step: string]: string[]; // step \"1\" -> [\"accId1\", \"accId2\"]\r\n            }\r\n        }\r\n    };\r\n    test_brokers?: {\r\n        [brokerId: string]: {\r\n            loop_size: number;\r\n            matrix: {\r\n                [step: string]: string[];\r\n            }\r\n        }\r\n    };\r\n}\r\n\r\nexport interface ExecutionBatch {\r\n    brokerId: string;\r\n    trade: any; // The trade object with mapped symbol\r\n    accounts: any[]; // TradingAccount objects\r\n}\r\n\r\nexport class TradeDistributionManager {\r\n\r\n    // --- Configuration Loading ---\r\n    static async getDistributionConfig(): Promise<DistributionConfig | null> {\r\n        try {\r\n            const res = await fetch('/api/distribution/config', { cache: 'no-store' });\r\n            if (res.ok) {\r\n                const data = await res.json();\r\n                console.log(\"[TradeDistribution] Loaded Config:\", data);\r\n                return data;\r\n            } else {\r\n                console.error(`[TradeDistribution] Config fetch failed: ${res.status} ${res.statusText}`);\r\n            }\r\n        } catch (e) {\r\n            console.error(\"[TradeDistribution] Failed to load config\", e);\r\n        }\r\n        return null;\r\n    }\r\n\r\n    // --- Core Logic ---\r\n    static distributeTrade(\r\n        baseTrade: any,\r\n        accounts: TradingAccount[],\r\n        brokers: Broker[],\r\n        config: DistributionConfig | null,\r\n        isTestMode: boolean = false\r\n    ): ExecutionBatch[] {\r\n        const batches: ExecutionBatch[] = [];\r\n\r\n        console.log(`[TradeDistribution] Distributing Trade. TestMode: ${isTestMode}`);\r\n\r\n        // 1. Group Accounts by Broker (FILTERED by Mode)\r\n        const accountsByBroker: Record<string, TradingAccount[]> = {};\r\n\r\n        accounts.forEach(acc => {\r\n            // STRICT CHECK: Only allow TRADING accounts. Explicitly block DATAFEED.\r\n            if (acc.accountType !== 'TRADING' || acc.isDatafeed) {\r\n                // console.log(`[TradeDistribution] Excluding Datafeed: ${acc.login}`);\r\n                return;\r\n            }\r\n\r\n            // MODE CHECK:\r\n            if (isTestMode) {\r\n                // In Test Mode, ONLY accept Test Accounts\r\n                if (!acc.isTest) return;\r\n            } else {\r\n                // In Live Mode, ONLY accept Live Accounts (isTest false/undefined)\r\n                if (acc.isTest) return;\r\n            }\r\n\r\n            if (!accountsByBroker[acc.brokerId]) accountsByBroker[acc.brokerId] = [];\r\n            accountsByBroker[acc.brokerId].push(acc);\r\n        });\r\n\r\n        // 2. Iterate Brokers\r\n        Object.keys(accountsByBroker).forEach(brokerId => {\r\n            const brokerAccounts = accountsByBroker[brokerId];\r\n            const brokerNode = brokers.find(b => b.id === brokerId);\r\n\r\n            if (!brokerNode) {\r\n                console.warn(`[TradeDistribution] Unknown broker ID: ${brokerId}`);\r\n                return;\r\n            }\r\n\r\n            // --- Symbol Mapping ---\r\n            // Clone the trade to avoid mutating the original\r\n            const mappedTrade = { ...baseTrade };\r\n\r\n            // Apply Mapping if exists\r\n            if (brokerNode.symbolMappings && brokerNode.symbolMappings[baseTrade.symbol]) {\r\n                mappedTrade.symbol = brokerNode.symbolMappings[baseTrade.symbol];\r\n                console.log(`[TradeDistribution] Mapped ${baseTrade.symbol} -> ${mappedTrade.symbol} for ${brokerNode.name}`);\r\n            }\r\n\r\n            // --- Distribution Matrix Logic ---\r\n            let targetAccountIds: string[] = [];\r\n\r\n            // Select Correct Config Section based on Mode\r\n            const brokerConfigMap = isTestMode ? config?.test_brokers : config?.brokers;\r\n            const prefix = isTestMode ? 'TEST_' : '';\r\n\r\n            // Fuzzy Lookup: Try ID -> Name -> Shorthand\r\n            let brokerConfig = brokerConfigMap?.[brokerId];\r\n            if (!brokerConfig && brokerConfigMap && brokerNode) {\r\n                // Determine potential keys provided in config\r\n                brokerConfig = brokerConfigMap[brokerNode.name] || brokerConfigMap[brokerNode.shorthand];\r\n\r\n                if (brokerConfig) {\r\n                    console.log(`[TradeDistribution] Found config using name/shorthand fallback for '${brokerNode.name}'`);\r\n                } else {\r\n                    console.log(`[TradeDistribution] DEBUG: Broker Lookup Failed. ID: '${brokerId}', Name: '${brokerNode.name}'`);\r\n                }\r\n            }\r\n\r\n            if (brokerConfig) {\r\n                // 1. Load Counter (Separate Counter for Test Mode?)\r\n                // YES, use separate counter keys to avoid messing up live rotation\r\n                const counterKey = `distribution_counter_${prefix}${brokerId}`;\r\n                let currentStep = parseInt(localStorage.getItem(counterKey) || '1');\r\n\r\n                // Safety check loop size\r\n                const loopSize = brokerConfig.loop_size || 1;\r\n                if (currentStep > loopSize) currentStep = 1;\r\n\r\n                console.log(`[TradeDistribution] Broker ${brokerNode.name} (${isTestMode ? 'TEST' : 'LIVE'}) - Step ${currentStep} of ${loopSize}`);\r\n\r\n                // 2. Get Accounts for current step directly from Matrix\r\n                const stepAccounts = brokerConfig.matrix[String(currentStep)];\r\n\r\n                if (stepAccounts && stepAccounts.length > 0) {\r\n                    targetAccountIds = stepAccounts;\r\n                } else {\r\n                    console.warn(`[TradeDistribution] No accounts configured for Step ${currentStep} in ${brokerNode.name}`);\r\n                }\r\n\r\n                // 3. Increment Counter for NEXT time\r\n                let nextStep = currentStep + 1;\r\n                if (nextStep > loopSize) nextStep = 1;\r\n                localStorage.setItem(counterKey, String(nextStep));\r\n\r\n            } else {\r\n                // FALLBACK LOGIC\r\n                if (isTestMode) {\r\n                    // Test Mode: Default to ALL available accounts if no config exists\r\n                    // This ensures \"Test Environment\" switch works out-of-the-box for mapped accounts\r\n                    console.log(`[TradeDistribution] No explicit Test Config for ${brokerNode.name}. Defaulting to ALL available test accounts.`);\r\n                    targetAccountIds = brokerAccounts.map(a => a.id);\r\n                } else {\r\n                    // Live Mode: STRICT. If no config exists, we do NOT distribute.\r\n                    console.warn(`[TradeDistribution] No configuration found for broker ${brokerNode.name} (Live Mode). STRICT: Skipping.`);\r\n                    targetAccountIds = [];\r\n                }\r\n            }\r\n\r\n            // Filter out Accounts that might be in config but not in the passed accounts list\r\n            const validAccounts = brokerAccounts.filter(a => targetAccountIds.includes(a.id));\r\n\r\n            if (validAccounts.length > 0) {\r\n                batches.push({\r\n                    brokerId: brokerId,\r\n                    trade: mappedTrade,\r\n                    accounts: validAccounts // Send full objects for backend routing\r\n                });\r\n            }\r\n        });\r\n\r\n        return batches;\r\n    }\r\n}\r\n"],"names":[],"mappings":"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"}},
    {"offset": {"line": 3085, "column": 0}, "map": {"version":3,"sources":["file:///C:/Users/Michael/IdeaProjects/MSMTB/src/trading-cockpit/src/lib/client-api.ts"],"sourcesContent":["const BACKEND_URL = 'http://127.0.0.1:3005/api';\r\nconst NEXT_API_URL = '/api';\r\n\r\n/**\r\n * Fetches directly from the Backend (Port 3005).\r\n * Use this for high-frequency data (Accounts, Brokers, Mappings, History).\r\n * Bypasses Next.js Dev Server proxy to ensure <10ms latency.\r\n */\r\nexport async function fetchDirect(endpoint: string, options?: RequestInit) {\r\n    // Ensure endpoint starts with / and remove it if double\r\n    let cleanPath = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\r\n\r\n    // Fix Double API Issue: If Backend URL ends with /api and Path starts with /api, strip one.\r\n    if (BACKEND_URL.endsWith('/api') && cleanPath.startsWith('/api/')) {\r\n        cleanPath = cleanPath.substring(4);\r\n    }\r\n\r\n    const url = `${BACKEND_URL}${cleanPath}`;\r\n\r\n    // Performance Trace\r\n    const start = performance.now();\r\n    console.log(`[PERF ${Date.now()}] [ClientAPI] ðŸŸ¡ FETCH START: ${cleanPath}`);\r\n\r\n    try {\r\n        const res = await fetch(url, options);\r\n        console.log(`[PERF ${Date.now()}] [ClientAPI] ðŸŸ¢ FETCH END: ${cleanPath} (Status: ${res.status}, Duration: ${(performance.now() - start).toFixed(2)}ms)`);\r\n        return res;\r\n    } catch (e) {\r\n        console.log(`[PERF ${Date.now()}] [ClientAPI] ðŸ”´ FETCH ERROR: ${cleanPath} (Duration: ${(performance.now() - start).toFixed(2)}ms)`);\r\n        throw e;\r\n    }\r\n}\r\n\r\n/**\r\n * Fetches via Next.js API Routes.\r\n * Use this for System Actions (Updates, Recovery, Filesystem Checks) that rely on Next.js server logic.\r\n */\r\nexport async function fetchSystem(endpoint: string, options?: RequestInit) {\r\n    const cleanPath = endpoint.startsWith('/') ? endpoint : `/${endpoint}`;\r\n    const url = `${NEXT_API_URL}${cleanPath}`;\r\n    return fetch(url, options);\r\n}\r\n\r\n/**\r\n * Common URLs for usage in fetching generic resources\r\n */\r\nexport const API_URLS = {\r\n    DIRECT_BASE: 'http://127.0.0.1:3005',\r\n    BACKEND_API: BACKEND_URL\r\n};\r\n"],"names":[],"mappings":";;;;;;;;AAAA,MAAM,cAAc;AACpB,MAAM,eAAe;AAOd,eAAe,YAAY,QAAgB,EAAE,OAAqB;IACrE,wDAAwD;IACxD,IAAI,YAAY,SAAS,UAAU,CAAC,OAAO,WAAW,CAAC,CAAC,EAAE,UAAU;IAEpE,4FAA4F;IAC5F,IAAI,YAAY,QAAQ,CAAC,WAAW,UAAU,UAAU,CAAC,UAAU;QAC/D,YAAY,UAAU,SAAS,CAAC;IACpC;IAEA,MAAM,MAAM,GAAG,cAAc,WAAW;IAExC,oBAAoB;IACpB,MAAM,QAAQ,YAAY,GAAG;IAC7B,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,GAAG,GAAG,8BAA8B,EAAE,WAAW;IAE3E,IAAI;QACA,MAAM,MAAM,MAAM,MAAM,KAAK;QAC7B,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,GAAG,GAAG,4BAA4B,EAAE,UAAU,UAAU,EAAE,IAAI,MAAM,CAAC,YAAY,EAAE,CAAC,YAAY,GAAG,KAAK,KAAK,EAAE,OAAO,CAAC,GAAG,GAAG,CAAC;QACxJ,OAAO;IACX,EAAE,OAAO,GAAG;QACR,QAAQ,GAAG,CAAC,CAAC,MAAM,EAAE,KAAK,GAAG,GAAG,8BAA8B,EAAE,UAAU,YAAY,EAAE,CAAC,YAAY,GAAG,KAAK,KAAK,EAAE,OAAO,CAAC,GAAG,GAAG,CAAC;QACnI,MAAM;IACV;AACJ;AAMO,eAAe,YAAY,QAAgB,EAAE,OAAqB;IACrE,MAAM,YAAY,SAAS,UAAU,CAAC,OAAO,WAAW,CAAC,CAAC,EAAE,UAAU;IACtE,MAAM,MAAM,GAAG,eAAe,WAAW;IACzC,OAAO,MAAM,KAAK;AACtB;AAKO,MAAM,WAAW;IACpB,aAAa;IACb,aAAa;AACjB"}}]
}